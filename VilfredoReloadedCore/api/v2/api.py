#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of VilfredoReloadedCore.
#
# Copyright Â© 2009-2015 Pietro Speroni di Fenizio / Derek Paterson.
#
# VilfredoReloadedCore is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation version 3 of the License.
#
# VilfredoReloadedCore is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with VilfredoReloadedCore.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################


'''
REST API
========

'''

from flask import request,\
    url_for, jsonify, make_response, abort
from VilfredoReloadedCore import app, models, emails
from VilfredoReloadedCore.auth import login_manager, login_serializer
from VilfredoReloadedCore.database import db_session
from sqlalchemy import and_, or_
from functools import wraps
from flask import Response
import json, os
import uuid


REST_API_VERSION = 'v2'
REST_URL = '/api'
REST_URL_PREFIX = REST_URL + '/' + REST_API_VERSION

RESULTS_PER_PAGE = 50
MAX_LEN_EMAIL = 120
MAX_LEN_USERNAME = 20
MAX_LEN_PASSWORD = 120
MIN_LEN_PASSWORD = 6
MAX_LEN_ROOM = 20
MIN_LEN_ROOM = 2
MAX_LEN_PROPOSAL_TITLE = 120
MAX_LEN_PROPOSAL_ABSTRACT = 5000
MAX_LEN_PROPOSAL_BLURB = 10000
MAX_LEN_QUESTION_TITLE = 120
MAX_LEN_QUESTION_BLURB = 10000
MAX_LEN_PROPOSAL_COMMENT = 1000
MAX_LEN_PROPOSAL_QUESTION = 1000
MAX_LEN_PROPOSAL_QUESTION_ANSWER = 1000
ENDORSEMENT_TYPES = ['endorse', 'oppose', 'confused']
COMMENT_TYPES = ['for', 'against', 'question', 'answer']


# &hellip; ....
# &NotGreaterLess;

DOMINATION_MAP_SYMBOLS = {-2: '&approx;', -1: '&equiv;', 0: '&hellip;', 1: '^', 2: '<', 3: '&uHar;', 4: '&lHar;', 5: '<span class="partial2full">^</span>', 6: '<span class="partial2full"><</span>'}


# For a given file, return whether it's an allowed type or not
def allowed_file(filename, permitted=None):
    permitted = permitted or app.config['ALLOWED_EXTENSIONS']
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in permitted

@login_manager.token_loader
def load_token(token):
    """
    Flask-Login token_loader callback.
    The token_loader function asks this function to take the token that was
    stored on the users computer process it to check if its valid and then
    return a User Object if its valid or None if its not valid.
    """

    app.logger.debug("load_token called...")

    #The Token itself was generated by User.get_auth_token.  So it is up to
    #us to known the format of the token data itself.

    #The Token was encrypted using itsdangerous.URLSafeTimedSerializer which
    #allows us to have a max_age on the token itself.  When the cookie is stored
    #on the users computer it also has a exipry date, but could be changed by
    #the user, so this feature allows us to enforce the exipry date of the token
    #server side and not rely on the users cookie to exipre.
    max_age = int(app.config["REMEMBER_COOKIE_DURATION"].total_seconds())

    #Decrypt the Security Token, data = [username, hashpass]
    #from . import login_serializer

    try:
        data = login_serializer.loads(token, max_age=max_age)
    except:
        app.logger.debug('load_token raised error')
        return None

    #Find the User
    user = models.User.get(int(data[0]))

    #Check Password and return user or None
    if user and data[1] == user.password:
        return user
    return None

def authenticate():
    """Sends a 403 response that enables basic auth"""
    return Response(
        'You have to login to make this request', 403,
        {'WWW-Authenticate': 'Basic realm="Login Required"'})

def requires_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        # app.logger.debug("request.authorization========>>>>: %s", request.authorization)
        auth = request.authorization
        if not auth:
            return jsonify(message='auth not defined'), 403
        if auth.username == '':
            return jsonify(message='no username received'), 403
        if auth.password == '':
            # app.logger.debug('requires_auth: Token set')
            token_valid = load_token(auth.username)
            if token_valid:
                # app.logger.debug('requires_auth: Token is valid')
                return f(*args, **kwargs)
            else:
                # app.logger.debug('requires_auth: Token is not valid')
                # return authenticate()
                return jsonify(message='no password received, incorrect token supplied'), 403
        elif check_auth(auth.username, auth.password):
            # app.logger.debug('requires_auth: username and password valid')
            return f(*args, **kwargs)
        else:
            # app.logger.debug('requires_auth: username and password not valid')
            # return authenticate()
            return jsonify(message='username and password not valid'), 403
    return decorated

def check_auth(username, password):
    '''
    .. function:: check_auth(username, password)

    Authenticates user.

    :param username: user name.
    :type username: String
    :param password: user name.
    :type password: String
    :rtype: Boolean
    '''
    user = None
    if username == '' or password == '':
        return False
    try:
        user = models.User.query.filter_by(username=username).one()
    except:
        pass
    if user is None:
        return False
    else:
        return user.check_password(password)

def get_authenticated_user(request):
    '''
    .. function:: get_authenticated_user(request)

    Returns the authenticated user.

    :param request: HTTP request.
    :type request: Object
    :rtype: User or None
    '''
    if request.authorization:
        if request.authorization.password == '':
            user = load_token(request.authorization.username)
            return user
        elif check_auth(request.authorization.username, request.authorization.password):
            user = models.User.query.\
                filter_by(username=request.authorization.username).one()
            return user
        else:
            return None
    else:
        app.logger.debug("get_authenticated_user: no authorization sent")
        return None


@app.errorhandler(404)
def not_found(error):
    return make_response(jsonify({'error': 'Not found'}), 404)


@app.errorhandler(400)
def bad_request(error):
    return make_response(jsonify({'error': 'Bad request'}), 400)


#
# Index
#
@app.route(REST_URL, methods=['GET'])
@app.route(REST_URL + '/', methods=['GET'])
@app.route(REST_URL + '/index', methods=['GET'])
def api_index():
    '''
    .. http:get:: /

        An authentication token.

        **Example request**:

        .. sourcecode:: http

            GET / HTTP/1.1
            Host: vilfredo.org
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
                "current_api_url": "https://example.com/api/v2",
                "api_v1_url": "https://example.com/api/v1",
                "api_v2_url": "https://example.com/api/v2",
            }

        :statuscode 200: no error
    '''
    app.logger.debug("api_index called...\n")

    api_info = {
        "current_api_url": "https://" + app.config['SITE_DOMAIN'] + REST_URL_PREFIX,
        "api_v1_url": "https://" + app.config['SITE_DOMAIN'] + "/api/v1",
        "api_v2_url": "https://" + app.config['SITE_DOMAIN'] + "/api/v2"
    }
    return jsonify(api_info), 200


#
# Get Auth Token
#
@app.route(REST_URL_PREFIX + '/authtoken', methods=['POST'])
@requires_auth
def api_get_auth_token():
    '''
    .. http:get:: /authtoken/

        An authentication token.

        **Example request**:

        .. sourcecode:: http

            GET /authtoken HTTP/1.1
            Host: vilfredo.org
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
               "token": "fr56gy6fuj78hg6549judhyey"
            }

        :statuscode 200: no error
        :statuscode 400: there's no user
    '''
    app.logger.debug("api_get_auth_token called...\n")
    user = get_authenticated_user(request)
    if not user:
        return jsonify(message = "User not logged in"), 404

    # Check if user needs to verify his email address
    verify_email = models.VerifyEmail.query.filter_by(user_id=user.id).first()
    if verify_email:
        return jsonify(message = "User email unverified.",
                       user_message = "Before you can log in you must activate your account by clicking on the link we emailed to you when you registered."), 400

    import datetime
    user.last_seen = datetime.datetime.utcnow()
    db_session.add(user)
    db_session.commit()
    
    token = user.get_auth_token()
    response = {'token': token}

    if request.json and 'eit' in request.json:
        app.logger.debug('Email Invite Token found...')
        email_invite_token = request.json['eit']
        question_id = models.EmailInvite.accept(user, email_invite_token)
        # Check if token OK
        if question_id:
            response['question_url'] = url_for('display_question', question_id=question_id)
            app.logger.debug('User accepted invite to question %s...', question_id)
        else:
            app.logger.debug('User accept invite to question %s failed for some reason...', question_id)

    return jsonify(response), 200

#
# Get Current User details
#
@app.route(REST_URL_PREFIX + '/currentuser', methods=['GET'])
@requires_auth
def api_get_current_user():
    '''
    .. http:get:: /currentuser

        Get the current user.

        **Example request**:

        .. sourcecode:: http

            GET /users/42 HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
                "user": 
                {   "username": "john", 
                    "url": "/api/v1/users/1", 
                    "registered": "2015-01-17 23:06:08", 
                    "id": "1", 
                    "email": "john@example.com", 
                    "last_seen": "2015-01-17 23:06:08"
                }
            }

        :param user_id: user id
        :type user_id: int
        :statuscode 200: no error
        :statuscode 401: there's no user
    '''
    app.logger.debug("api_get_current_user called...\n")
    user = get_authenticated_user(request)
    if not user:
        app.logger.debug("user not found...\n")
        abort(401)
    userdata = user.get_public()
    userdata['email'] = user.email
    return jsonify(user=userdata), 200


#
# Get Users
#
@app.route(REST_URL_PREFIX + '/users', methods=['GET'])
@app.route(REST_URL_PREFIX + '/users/<int:user_id>', methods=['GET'])
def api_get_users(user_id=None):
    '''
    .. http:get:: /users/(int:user_id)

        A user or list of associated users.

        **Example request**:

        .. sourcecode:: http

            GET /users/42 HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
               "total_items": 5,
               "items": "2",
               "objects":
               [
                   {
                       "username": "john",
                       "url": "/users/1",
                       "registered": "2013-08-12 09:51:38.559222",
                       "id": "1",
                       "last_seen": "2013-08-12 09:51:38.559240"
                   },
                   {
                       "username": "susan",
                       "url": "/users/2",
                       "registered": "2013-08-12 09:51:38.576731",
                       "id": "2",
                       "last_seen": "2013-08-12 09:51:38.576745"
                   }
               ],
               "page": "1",
               "pages": "2"
            }

        :param user_id: user id
        :type user_id: int
        :query page: page number. default is 1
        :statuscode 200: no error
        :statuscode 404: there's no user
    '''
    app.logger.debug("api_get_users called...\n")

    # Get authenticated user or None
    current_user = get_authenticated_user(request)

    if user_id is not None:
        # user = models.User.query.get(int(user_id))
        # if user is None:
        #     abort(404)

        if current_user and current_user.id == user.id:
            results = current_user.get_public()
            results['email'] = current_user.email
            return jsonify(user=results), 200
        else:
            user = current_user.get_associated_user(userid)
            if user is None:
                response = {"message": "User not found"}
                return jsonify(response), 400

            results = user.get_public()
            return jsonify(user=results), 200

    else:
        page = int(request.args.get('page', 1))

        # users = models.User.query.paginate(page,
        #                                   RESULTS_PER_PAGE,
        #                                  False)
        users = user.get_associated_users(page)

        items = len(users.items)
        pages = users.pages
        total_items = users.total

        results = []
        for u in users.items:
            results.append(u.get_public())

        return jsonify(total_items=total_items, items=str(items),
                       page=str(page), pages=str(pages),
                       users=results), 200


# Update User Details
@app.route(REST_URL_PREFIX + '/users/<int:user_id>', methods=['POST'])
@requires_auth
def api_update_user(user_id):
    '''
    .. http:post:: /users/(int:user_id)

        Update a user's details'.

        **Example request**:

        .. sourcecode:: http

            POST /users/42 HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
                "url": "/users/1"
            }

        :param user_id: user id
        :type user_id: int
        :json new_username: new username
        :json new_password: new password
        :json new_email: new email address
        :statuscode 200: no error
        :statuscode 404: there's no user
    '''
    if user_id is None:
        abort(404)

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    app.logger.debug("api_update_user called by %s...\n", user.id)

    if int(user_id) != user.id:
        response = {'message': 'You are not authorized to edit this resource'}
        return jsonify(objects=response), 401

    if not request.json:
        app.logger.debug("Non json request received...\n")
        abort(400)

    elif 'new_username' in request.json and \
            (request.json['new_username'] == '' or
             len(request.json['new_username']) > MAX_LEN_USERNAME):
        app.logger.debug("1...\n")
        abort(400)

    elif 'new_email' in request.json and \
            (request.json['new_email'] == '' or
             request.json['new_email'] > MAX_LEN_EMAIL):
        app.logger.debug("2...\n")
        abort(400)

    elif 'new_password' in request.json and \
            (len(request.json['new_password']) < MIN_LEN_PASSWORD or
             len(request.json['new_password']) > MAX_LEN_PASSWORD):
        app.logger.debug("3...\n")
        abort(400)

    elif models.User.username_available(request.json['new_username'])\
            is not True:
        message = "Username not available"
        # return jsonify(message=message), 400
        return jsonify(message = "Username not available"), 400

    elif models.User.email_available(request.json['email']) is not True:
            response = {'message': 'Someone has already registered with that email.'}
            return jsonify(objects=response), 400

    user.username = request.json.get('new_username', user.username)
    user.email = request.json.get('new_email', user.email)

    if 'new_password' in request.json:
        user.set_password(request.json['new_password'])

    db_session.add(user)
    db_session.commit()
    response = {'url': url_for('api_get_users', user_id=user.id)}

    return jsonify(object=response), 201


#
# Upload avatar
#
@app.route(REST_URL_PREFIX + '/upload_avatar', methods=['POST'])
@requires_auth
def api_upload_avatar():
    '''
    .. http:post:: /upload_avatar

        Upload user avatar.

        **Example request**:

        .. sourcecode:: http

            POST /users HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
                "message": "File saved",
                "url": "http://0.0.0.0:8080/static/usercontent/profiles/1/831e44b41f77c66d6f97aa8ee4977275.jpg"
            }

        :json email: registered email address
        :statuscode 201: no error
        :statuscode 400: bad request
        :statuscode 401: bad request
    '''
    app.logger.debug("api_upload_avatar called.....\n")
    
    # Must be authenticated
    user = get_authenticated_user(request)
    if not user:
        app.logger.debug("api_upload_avatar: user not logged in.....\n")
        response = {"message": "User not logged in"}
        return jsonify(response), 400

    # avatars = UploadSet('avatars', IMAGES)

    app.logger.info("requst data %s", request.files)
    app.logger.info("requst data %s", request.files['avatar'])
    avatar = request.files['avatar']
    app.logger.info("avatar file = %s", avatar)
    app.logger.info("avatar filename = %s", avatar.filename)
    if not avatar:
        message = 'Failed to upload file'
        return jsonify(message=message, error=message), 401
    
    if not allowed_file(avatar.filename):
        message = 'Avatar file must be of type: ' + ', '.join(app.config['ALLOWED_EXTENSIONS'])
        return jsonify(message=message, error=message), 401

    avatar_saved = user.set_avatar(avatar)

    if avatar_saved == False:
        message = 'Failed to save file'
        return jsonify(message=message, error=message), 401

    message = 'Avatar saved'
    return jsonify(message=message,
                   url=app.config['PROTOCOL'] + app.config['SITE_DOMAIN'] + '/' + avatar_saved), 201


#
# Password reset request
#
@app.route(REST_URL_PREFIX + '/request_password_reset', methods=['POST'])
def api_request_password_reset():
    '''
    .. http:post:: /request_password_reset

        Request password reset.

        **Example request**:

        .. sourcecode:: http

            POST /users HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
                "message": "Password reset email sent"
            }

        :json email: registered email address
        :statuscode 201: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_request_password_reset called.....\n")

    if not request.json:
        app.logger.debug("Non json request received...\n")
        message = "Non json request received"
        return jsonify(message=message), 401

    elif not 'email' in request.json or request.json['email'] == '' \
            or len(request.json['email']) > MAX_LEN_EMAIL:
        message = "A valid email is required"
        return jsonify(message=message), 402

    user_data = request.json['email']
    app.logger.debug("Reset data given = %s\n", user_data)
    # user = models.User.query.filter_by(email=email).first()
    user = models.User.query.filter(or_(models.User.username==user_data, models.User.email==user_data)).first()

    if not user:
        message = "Sorry, no user was found which matched your details."
        return jsonify(message=message), 403

    email = user.email
    email_verification_pending = models.VerifyEmail.query.filter(models.VerifyEmail.email == email).first()
    if email_verification_pending:
        message = "The user account associated with your details has not been activated yet. Please use the activation link previously sent to your registred address or register again."
        return jsonify(message=message), 403

    pwd_reset = db_session.query(models.PWDReset)\
            .filter(models.PWDReset.email == email)\
            .first()

    if pwd_reset:
        # Resend if token still valid
        if pwd_reset.timeout > models.get_timestamp():
            # Resend if token still valid
            app.logger.debug('Valid token found. Resending to %s', email)
            ret_code = emails.send_password_reset_email(email, pwd_reset.token)
            app.logger.debug("api_request_password_reset: Password reset token rsent to address %s", email)
            message = 'The password reset token has been resent to your address. Please check your spam folder.'
            return jsonify(message=message), 201
        else:
            # Reset token and timeout
            app.logger.debug('Expired token found. Resend new token to %s', email)
            pwd_reset.token = uuid.uuid4().get_hex()
            pwd_reset.timeout = models.get_timestamp() + app.config['PWD_RESET_LIFETIME']
            db_session.add(pwd_reset)
            db_session.commit()
            # email reset token to user
            app.logger.debug('Resending new password reset token to %s', email)
            ret_code = emails.send_password_reset_email(email, pwd_reset.token)
            app.logger.debug("api_request_password_reset: Ret Code from send_password_reset_email = %s", ret_code)
            message = 'A new password reset token has been sent to your address. Please check your spam folder.'
            return jsonify(message=message), 201

    # else generate a new token
    else:
        app.logger.debug('Send new password reset token to %s', email)
        pwd_reset_token = uuid.uuid4().get_hex()
        timeout = models.get_timestamp() + app.config['PWD_RESET_LIFETIME']
        pwd_reset = models.PWDReset(user, pwd_reset_token, timeout)
        db_session.add(pwd_reset)
        db_session.commit()
        # email reset token to user
        ret_code = emails.send_password_reset_email(email, pwd_reset_token)
        app.logger.debug("api_request_password_reset: Ret Code from send_password_reset_email = %s", ret_code)
        message = 'A new password reset token has been sent to your address. Please check your spam folder.'
        return jsonify(message=message), 201


#
# Set new password and generate new authentication token
#
@app.route(REST_URL_PREFIX + '/reset_password', methods=['POST'])
def api_reset_password():
    '''
    .. http:post:: /reset_password

        Request password reset.

        **Example request**:

        .. sourcecode:: http

            POST /users HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
                "message": "Password reset",
                "token": "gd6ghgjh7d6hehftt76gTR5677eh"
            }

        :json password: new password
        :json password2: new password confirmation
        :json token: password reset token
        :statuscode 201: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_reset_password called...\n")

    if not 'token' in request.json or request.json['token'] == '':
        message = 'You must pass a password reset token'
        return jsonify(message=message), 402
    reset_token = request.json['token']

    if not 'password' in request.json or not 'password2' in request.json or \
            request.json['password'] != request.json['password2'] or \
            request.json['password'] == '' or \
            len(request.json['password']) < MIN_LEN_PASSWORD or \
            len(request.json['password']) > MAX_LEN_PASSWORD:
        message = "Passwords %s must match and must be between %s and %s characters" %\
            (request.json['password'], MIN_LEN_PASSWORD, MAX_LEN_PASSWORD)
        return jsonify(message=message), 400

    pwd_reset = db_session.query(models.PWDReset)\
            .filter(models.PWDReset.token == reset_token)\
            .first()

    if not pwd_reset:
        response = {"message": "Invalid password reset token"}
        return jsonify(response), 400

    # Check for expired reset token entry
    elif pwd_reset.timeout < models.get_timestamp():
        # Delete expired reset token entry
        db_session.delete(pwd_reset)
        response = {"message": "This password reset token has expired. Please request a new one if still required."}
        return jsonify(response), 400

    user = models.User.query.get(pwd_reset.user_id)
    if not user:
        response = {"message": "User not found"}
        return jsonify(response), 400

    app.logger.debug("User from token = %s\n", user.id)

    # Delete reset token entry
    db_session.delete(pwd_reset)

    # Set new password
    new_password = request.json['password']
    user.set_password(new_password)
    db_session.add(user)
    db_session.commit()

    # Generate new auth token
    authtoken = user.get_auth_token()
    app.logger.debug("New auth token generated")

    message = 'Password reset'
    return jsonify(message=message, token=authtoken), 201


#
# Create User
#
@app.route(REST_URL_PREFIX + '/users', methods=['POST'])
def api_create_user():
    '''
    .. http:post:: /users

        Create a new user.

        **Example request**:

        .. sourcecode:: http

            POST /users HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
                "url": "/users/1",
                "email_sent": true
            }

        :json username: username
        :json email: email address
        :json password: password
        :statuscode 201: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_create_user called...\n")

    app.logger.debug("Request %s...\n", request.json)

    if not request.json:
        app.logger.debug("Non json request received...\n")
        message = "Non json request received"
        return jsonify(message=message), 400

    # Check if token required for registration
    if app.config['REGISTER_INVITATION_ONLY']:
        if 'eit' not in request.json or not models.EmailInvite.check_token(request.json['eit']):
            message = "Sorry, currently registration on this site is by invitation only!<br><br>If you wish to test Vilfredo you can register at the <a href='http://demo.vilfredo.org' title='Vilfredo Demo site'>Vilfredo Demo site</a>."
            return jsonify(message=message), 400

    if not 'username' in request.json or request.json['username'] == '' \
            or len(request.json['username']) > MAX_LEN_USERNAME:
        message = "Username must be less than %s characters" % MAX_LEN_USERNAME
        return jsonify(message=message), 400

    elif not 'email' in request.json or request.json['email'] == '' \
            or len(request.json['email']) > MAX_LEN_EMAIL:
        message = "Email required and must be shorter than %s characters" %\
                  MAX_LEN_EMAIL
        return jsonify(message=message), 400

    elif not 'password' in request.json or request.json['password'] == '' or \
            len(request.json['password']) < MIN_LEN_PASSWORD or \
            len(request.json['password']) > MAX_LEN_PASSWORD:
        message = "Password must be between %s and %s characters" %\
            (MIN_LEN_PASSWORD, MAX_LEN_PASSWORD)
        return jsonify(message=message), 400

    user_email = request.json['email']
    email_verification_pending = models.VerifyEmail.query.filter(models.VerifyEmail.email == user_email).first()
    if email_verification_pending:
        if email_verification_pending.timeout > models.get_timestamp():
            # If valid activation pending send another email
            ret_code = emails.send_email_verification(email_verification_pending.user_id, user_email, email_verification_pending.token, email_verification_pending.timeout)
            app.logger.debug("api_create_user: Ret Code from send_email_verification = %s", ret_code)
            db_session.commit()
            message = "There is still an activations pending on that email address. A second activation email has been sent to your address."
            return jsonify(message=message), 201
        else:
            # Else delete token and previous user details - start again with the new data
            unvalidated_user = models.User.query.get(email_verification_pending.user_id)
            if unvalidated_user:
                app.logger.debug('Deleteing expired unvalidated user account for %s', unvalidated_user.username)
                db_session.delete(unvalidated_user)
                db_session.delete(email_verification_pending)
                db_session.commit()

    # See if that name is being blocked by an expired activation token - if so delete token and unvalidated user
    username = request.json['username']
    user = models.User.query.filter_by(username=username).first()
    if user:
        # Userame available if user is connected to an expired validation token
        email_verification_pending = models.VerifyEmail.query.filter(models.VerifyEmail.email == user.email).first()
        if email_verification_pending:
            if email_verification_pending.timeout < models.get_timestamp():
                # Delete unvalidated user and expired token to free username
                app.logger.debug('Deleteing expired unvalidated user account for %s', user.username)
                db_session.delete(user)
                db_session.delete(email_verification_pending)
                db_session.commit()
            else:
                # Username not available while token valid
                app.logger.debug('username blocked by active token')
                message = "Sorry, that username is not available."
                return jsonify(message=message), 400
        else:
            # Username not available - held by active user
            app.logger.debug('username used by validated user')
            message = "Sorry, that username is not available."
            return jsonify(message=message), 400

    # Check if email registered to active user
    if models.User.email_available(request.json['email']) is not True:
        message = "Someone has already registered with that email."
        return jsonify(message=message), 400


    # OK! That's a bingo! Proceed to create new user...
    user = models.User(request.json['username'],
                       request.json['email'],
                       request.json['password'])
    db_session.add(user)
    db_session.commit()

    verify_new_users_email_address = True
    response = {}
    email_sent = False

    if 'eit' in request.json:
        app.logger.debug('Email Invite Token found: %s', request.json['eit'])
        email_invite_token = request.json['eit']
        question_id = models.EmailInvite.accept(user, email_invite_token)
        # Check if token OK
        if question_id:
            app.logger.debug('User %s accepted invite to question %s...', user.username, question_id)
            # No need to verify email address
            verify_new_users_email_address = False
            # Create auth token to log the user in
            auth_token = user.get_auth_token()

            # Check if question still exists - eg hasn't been deleted
            question = models.Question.query.get(question_id)
            if question:
                app.logger.debug('Question Found: send %s a welcome_to_question_email to %s...', user.username, user.email)
                emails.send_welcome_to_question_email(user, question)
            else:
                app.logger.debug('Question Not Found: send %s a welcome_to_notfound_question_email to %s...', user.username, user.email)
                emails.send_welcome_to_notfound_question_email(user, question_id)

            response = {'url': url_for('api_get_users', user_id=user.id), 
                        'token': auth_token, 'activation_email_sent': False}

            # send question link only if question acually exists
            if question:
                response['question_url'] = url_for('display_question', question_id=question_id)

    else:
        response = {'url': url_for('api_get_users', user_id=user.id), 'activation_email_sent': False}

    # Send verification email unless deactivate
    if verify_new_users_email_address and os.environ.get('EMAIL_VALIDATION_OFF', '0') == '0':
        email = request.json['email']
        token = uuid.uuid4().get_hex()
        timeout = models.get_timestamp() + int(app.config["EMAIL_VERIFY_LIFETIME"].total_seconds())
        verify_email = models.VerifyEmail(user, email, token, timeout)
        ret_code = emails.send_email_verification(user.id, email, token, timeout)
        app.logger.debug("api_create_user: Ret Code from send_email_verification = %s", ret_code)
        verify_email.email_sent = 1
        db_session.add(verify_email)
        db_session.commit()
        response['activation_email_sent'] = True
        response['message'] = 'An activation email has been sent to your email address. Please check your spam folder.'

    return jsonify(response), 201



#
# Get Questions  fetch questions
#
@app.route(REST_URL_PREFIX + '/questions', methods=['GET'])
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>', methods=['GET'])
@requires_auth
def api_get_questions(question_id=None):
    '''
    .. http:get:: /questions/(int:question_id)

        A question or list of questions.

        **Example request**:

        .. sourcecode:: http

            GET /questions/42 HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "total_items": "3",
              "items": "2",
              "objects": [
                {
                  "last_move_on": "2013-08-12 09:51:38.632780",
                  "created": "2013-08-12 09:51:38.632763",
                  "title": "My question",
                  "minimum_time": "0",
                  "maximum_time": "604800",
                  "id": 1,
                  "blurb": "My blurb"
                },
                {
                  "last_move_on": "2013-08-12 09:51:38.665584",
                  "created": "2013-08-12 09:51:38.665570",
                  "title": "Too Many Chefs",
                  "minimum_time": "0",
                  "maximum_time": "604800",
                  "id": 3,
                  "blurb": "How can they avoid spoiling the broth?"
                }
              ],
              "page": "1",
              "pages": "1"
            }

        :param question_id: question id
        :type question_id: int
        :param room: room title
        :type room: string
        :query page: page number. default is 1
        :statuscode 200: no error
        :statuscode 404: there's no user
    '''
    app.logger.debug("api_get_questions called...\n")

    user = get_authenticated_user(request)
    if not user:
        response = {"message": "User not logged in"}
        return jsonify(response), 400

    if question_id is not None:

        question = models.Question.query.get(question_id)
        if question is None:
            return jsonify(message = "Question not found"), 404

        # Check user permission fff
        perm = question.get_permissions(user)
        if not perm:
            app.logger.debug("ACCESS ERROR: User %s tried to access question %s", user.id, question.id)
            return jsonify(message = app.config['QUESTION_PERMISSION_DENIED_MESSAGE']), 400

        # question_data = question.get_public(user)

        if perm == models.Question.permission_types['MODERATE']:
            question_data = question.get_anonymized(user)
        else:
            question_data = question.get_public(user)

        if perm == models.Question.permission_types['MODERATE']:
            question_data['is_moderator'] = True
        else:
            question_data['is_moderator'] = False

        if question.user_id == user.id:
            question_data['is_author'] = True
        else:
            question_data['is_author'] = False

        app.logger.debug("Question data ==> %s", question_data);

        # Test for jsonp request
        if False or 'callback' in request.args:
            d = json.dumps(dict(question=question_data))
            return request.args['callback'] + '(' + d + ');', 200
        else:
            return jsonify(question=question_data), 200

    else:
        questions = user.get_active_questions()
        items = len(questions)

        results = []
        for q in questions:
            results.append(q.get_public(user))

        # Test for jsonp request
        if False or 'callback' in request.args:
            d = json.dumps(dict(items=str(items),
                           questions=results))
            return request.args['callback'] + '(' + d + ');', 200

        else:
            return jsonify(items=str(items),
                           questions=results), 200

#
# Create Question  Add Question
#
@app.route(REST_URL_PREFIX + '/questions', methods=['POST'])
@requires_auth
def api_create_question():
    '''
    .. http:post:: /questions

        Create a question.

        **Example request**:

        .. sourcecode:: http

            POST /questions HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
                "url": "/questions/1"
            }

        :json title: question title
        :json blurb: question content
        :json question_type: proposal type
        :json voting_type: voting type
        :statuscode 201: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_create_question called...\n")

    user = get_authenticated_user(request)
    if not user:
        response = {"message": "User not logged in"}
        return jsonify(response), 400

    app.logger.debug("Authenticated User = %s\n", user.id)

    if not request.json:
        app.logger.debug("Non json request received...\n")
        response = {'message': "No question data received"}
        return jsonify(response), 400

    if not 'title' in request.json or request.json['title'] == ''\
            or len(request.json['title']) > MAX_LEN_QUESTION_TITLE:
        response = {'message': "Question title must not be empty and no longer than " + str(MAX_LEN_QUESTION_BLURB) + " characters"}
        return jsonify(response), 400

    elif not 'blurb' in request.json or request.json['blurb'] == ''\
            or len(request.json['blurb']) > MAX_LEN_QUESTION_BLURB:
        # abort(400)
        response = {'message': "Question text must not be empty and no longer than " + str(MAX_LEN_QUESTION_BLURB) + " characters"}
        return jsonify(response), 400


    # Check link count in blurb
    blurb = request.json.get('blurb')
    num_links = blurb.count('http')
    app.logger.debug("%s links in quetion text", num_links)
    if num_links > app.config['MAX_LINKS_IN_QUESTION']:
        message = "Text contains %s links. Text can contain no more than %s links" % (num_links, app.config['MAX_LINKS_IN_QUESTION'])
        return jsonify(message=message), 400
    elif num_links > app.config['MAX_LINKS_IN_QUESTION_WITHOUT_VALIDATION']: 
        if 'recaptcha' not in request.json or len(request.json['recaptcha']) == 0:
            message = "Text contains %s links. Text containing more than %s links requires validation with recaptcha" % (num_links, app.config['MAX_LINKS_IN_QUESTION_WITHOUT_VALIDATION'])
            return jsonify(message=message), 400
        else:
            import requests
            params = {'secret': app.config['RECAPTCHA_SECRET'], 'response': request.json['recaptcha']}
            r = requests.post(app.config['RECAPTCHA_API_URL'], data=params)
            if not r.ok:
                message = "Text contains %s links. Invalid recaptcha parameter value received." % (num_links)
                return jsonify(message=message), 400

    title = request.json.get('title')
    question_type = request.json.get('question_type', 1)
    voting_type = request.json.get('voting_type', 1)

    # Get author permissions - defaults to VOTE_PROPOSE_READ
    author_permissions = int(request.json.get('permissions', models.Question.VOTE_PROPOSE_READ))

    question = models.Question(author=user, 
                               title=title,
                               blurb = blurb,
                               question_type=question_type,
                               voting_type=voting_type)

    db_session.add(question)
    db_session.commit()

    # Set default threshold for voting map
    question.thresholds.append(models.Threshold(question))
    # Set author permissions
    user.invites.append(models.Invite(user, user.id, author_permissions, question.id))
    db_session.commit()

    # url = {'url': url_for('api_get_questions', question_id=question.id)}
    # return jsonify(url), 201

    return jsonify(question=question.get_public()), 201




# Get proposals (Fetch Proposals)
#
# Add options to return only pareto, inherited or new user proposals
#
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/proposals', methods=['GET'])
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/proposals/<int:proposal_id>',
           methods=['GET'])
@requires_auth
def api_get_question_proposals(question_id=None, proposal_id=None):
    '''
    .. http:get:: /questions/(int:question_id)/proposals/(int:proposal_id)

        A proposal or list of proposals for a qustion.

        **Example request**:

        .. sourcecode:: http

            GET /questions/22/proposals HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
                "total_items": "4",
                "items": "2",
                "proposals": [
                {
                  "question_url": "/api/v1/questions/1",
                  "author_url": "/api/v1/users/3",
                  "title": "Bills First Proposal",
                  "url": "/api/v1/questions/1/proposals/1",
                  "abstract": null,
                  "created": "2013-08-15 18:32:00.154844",
                  "id": "1",
                  "blurb": "Bills blurb of varying interest",
                  "generation_created": "1"
                },
                {
                  "question_url": "/api/v1/questions/1",
                  "author_url": "/api/v1/users/3",
                  "title": "Bills Second Proposal",
                  "url": "/api/v1/questions/1/proposals/2",
                  "abstract": "This is too abstract for an abstract",
                  "created": "2013-08-15 18:32:00.176816",
                  "id": "2",
                  "blurb": "Bills blurb of varying disinterest",
                  "generation_created": "1"
                }
                ],
                "page": "1",
                "pages": "2"
            }

        :param question_id: question ID
        :type question_id: int
        :param proposal_id: proposal ID
        :type proposal_id: int
        :query generation: question generation, default is current
        :query page: page number, default is 1
        :query user_only: boolean, default false
        :query inherited_only: boolean, default is false
        :statuscode 200: no error
        :statuscode 404: there's no proposal
    '''
    app.logger.debug("api_get_question_proposals called...\n")

    # See if user logged in
    app.logger.debug("Request: %s", request)
    if request.authorization:
        app.logger.debug("Request Authorization IS SET: %s", request.authorization)
    else:
        app.logger.debug("Request Authorization NOT SET")

    # if 'request.json' in locals() or 'request.json' in globals():
    #    app.logger.debug("BOOM!!!")

    user = get_authenticated_user(request)
    app.logger.debug("Got user...")
    if user:
        app.logger.debug("User logged in %s", user.username)
    else:
        app.logger.debug("User not logged in")
    # user = None

    if question_id is None:
        return jsonify({"message": "Parameter question_id not set"}), 404

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        return jsonify(message="Question not found"), 404

    # Check if user has permission to view the question
    perm = question.get_permissions(user)
    if not perm:
        app.logger.debug("ACCESS ERROR: User %s tried to access question %s", user.id, question.id)
        return jsonify(message = app.config['QUESTION_PERMISSION_DENIED_MESSAGE']), 400

    if not proposal_id is None:
        proposal_id = int(proposal_id)
        proposal = question.proposals.filter_by(id=proposal_id).first()
        if proposal is None:
            return jsonify(message="Proposal not found"), 404

        # result = proposal.get_public()
        
        if perm == models.Question.permission_types['MODERATE']:
            result = proposal.get_anonymized()
        else:
            result = proposal.get_public()

        # Test for jsonp request
        if False or 'callback' in request.args:
            d = json.dumps(dict(proposal=result))
            return request.args['callback'] + '(' + d + ');', 200
        else:
            return jsonify(proposal=result), 200

    else:
        generation = int(request.args.get('generation', question.generation))
        page = int(request.args.get('page', 1))

        # proposals = models.Proposal.query.join(models.QuestionHistory).\
        #    filter(models.QuestionHistory.question_id == question.id).\
        #    filter(models.QuestionHistory.generation == generation).\
        #    paginate(page, RESULTS_PER_PAGE, False)

        user_only = request.args.get('user_only', False)
        # Return empty list if user_only requested and user not authenticated
        if user_only and not user:
            app.logger.debug("api_get_question_proposals: user_only True but no current user, return empty list")
            return jsonify(total_items=0, items=0,
                          page=1, pages=1,
                          proposals=[]), 200

        inherited_only = request.args.get('inherited_only', False)
        # Return empty list if inherited_only requested and in first generation
        if inherited_only and question.generation == 1:
            return jsonify(total_items=0, items=0,
                          page=1, pages=1,
                          proposals=[]), 200

        query = models.Proposal.query.join(models.QuestionHistory).\
            filter(models.QuestionHistory.question_id == question.id).\
            filter(models.QuestionHistory.generation == generation)

        if user and user_only:
            app.logger.debug("api_get_question_proposals: user_only True, add user filter")
            query = query.filter(models.Proposal.user_id == user.id)
            query = query.filter(models.Proposal.generation_created == question.generation)

        elif inherited_only:
            query = query.filter(models.Proposal.generation_created < question.generation)

        proposals = query.paginate(page, RESULTS_PER_PAGE, False)

        items = len(proposals.items)
        pages = proposals.pages
        total_items = proposals.total

        results = []

        for p in proposals.items:

            # results.append(p.get_public(user))
            
            if perm == models.Question.permission_types['MODERATE']:
                results.append(p.get_anonymized(user))
            else:
                results.append(p.get_public(user))

        # Test for jsonp request
        if False or 'callback' in request.args:
            d = json.dumps(dict(total_items=str(total_items), items=str(items),
                           page=str(page), pages=str(pages),
                           proposals=results))
            return request.args['callback'] + '(' + d + ');', 200
        else:
            # Return json
            return jsonify(total_items=total_items, items=items,
                          page=page, pages=pages,
                          proposals=results), 200


# Support Comment
@app.route(
    REST_URL_PREFIX + '/questions/<int:question_id>/proposals/' +
    '<int:proposal_id>/comments/<int:comment_id>/support',
    methods=['POST'])
@requires_auth
def api_support_proposal_comment(question_id, proposal_id, comment_id):
    '''
    .. http:post:: /questions/(int:question_id)/proposals/(int:proposal_id)/comments/(int:comment_id)/support

        Update a comment.

        **Example request**:

        .. sourcecode:: http

            POST /questions/45/proposals/47/comments/77/support HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
                 "message": "Support Added"
            }

        :param question_id: question ID
        :type question_id: int
        :param proposal_id: proposal ID
        :type proposal_id: int
        :param comment_id: comment ID
        :type comment_id: int
        :statuscode 200: no error
        :statuscode 400: bad request
        :statuscode 401: unauthorized
        :statuscode 404: not found
    '''
    app.logger.debug("api_support_proposal_comment called...\n")

    user = get_authenticated_user(request)
    if not user:
        return jsonify({"message": "User not found"}), 401

    app.logger.debug("Authenticated User = %s\n", user.id)

    if question_id is None or proposal_id is None or comment_id is None:
        return jsonify(message = "URI parameters missing"), 400

    question = models.Question.query.get(int(question_id))
    if question is None:
        return jsonify(message = "Question not found"), 404

    # Check if user has permission to view the question
    perm = question.get_permissions(user)
    if not perm:
        app.logger.debug("ACCESS ERROR: User %s tried to access question %s", user.id, question.id)
        return jsonify(message = "You do not have permission to view this question"), 404

    # Check if user has permission to write comments - currently also prevents supporting
    # elif not models.Question.COMMENT & perm:
    elif not perm in [models.Question.PROPOSE_READ,
                      models.Question.VOTE_READ,
                      models.Question.VOTE_PROPOSE_READ,
                      models.Question.READ_COMMENT]:
        app.logger.debug("ACCESS ERROR: User %s with permission %s tried to support comments on question %s", user.id, perm, question.id)
        return jsonify(message = app.config['QUESTION_COMMENT_PERMISSION_DENIED_MESSAGE']), 400

    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        return jsonify(message = "Proposal not found"), 404

    comment = models.Comment.query.get(int(comment_id))
    if comment is None:
        return jsonify(message = "Comment not found"), 404

    # Support comment
    user.support_comments([comment])
    db_session.add(user)
    db_session.commit()

    # Return updated supporters list
    supporters = comment.fetch_supporter_ids()
    return jsonify(message="Support added",
                   supporters=str(supporters),
                   num_supporters = len(supporters)), 201


# Unsupport Comment
@app.route(
    REST_URL_PREFIX + '/questions/<int:question_id>/proposals/' +
    '<int:proposal_id>/comments/<int:comment_id>/support',
    methods=['DELETE'])
@requires_auth
def api_unsupport_proposal_comment(question_id, proposal_id, comment_id):
    '''
    .. http:delete:: /questions/(int:question_id)/proposals/(int:proposal_id)/comments/(int:comment_id)/support

        Update a comment.

        **Example request**:

        .. sourcecode:: http

            DELETE /questions/45/proposals/47/comments/77/support HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
                 "message": "Support Removed"
            }

        :param question_id: question ID
        :type question_id: int
        :param proposal_id: proposal ID
        :type proposal_id: int
        :param comment_id: comment ID
        :type comment_id: int
        :statuscode 200: no error
        :statuscode 400: bad request
        :statuscode 401: unauthorized
        :statuscode 404: not found
    '''
    app.logger.debug("api_unsupport_proposal_comment called...\n")

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    app.logger.debug("Authenticated User = %s\n", user.id)

    if question_id is None or proposal_id is None or comment_id is None:
        return jsonify(message = "URI parameters missing"), 400

    question = models.Question.query.get(int(question_id))
    if question is None:
        return jsonify(message = "Question not found"), 404
    
    # Check if user has permission to view the question
    perm = question.get_permissions(user)
    if not perm:
        app.logger.debug("ACCESS ERROR: User %s tried to access question %s", user.id, question.id)
        return jsonify(message = "You do not have permission to view this question"), 404

    # Check if user has permission to write comments - currently also prevents supporting
    #elif not models.Question.COMMENT & perm:
    elif not perm in [models.Question.PROPOSE_READ,
                      models.Question.VOTE_READ,
                      models.Question.VOTE_PROPOSE_READ,
                      models.Question.READ_COMMENT]:
        app.logger.debug("ACCESS ERROR: User %s with permission %s tried to support comments on question %s", user.id, perm, question.id)
        return jsonify(message = app.config['QUESTION_COMMENT_PERMISSION_DENIED_MESSAGE']), 400

    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        return jsonify(message = "Proposal not found"), 404

    comment = models.Comment.query.get(int(comment_id))
    if comment is None:
        return jsonify(message = "Comment not found"), 404

    # Support comment
    user.unsupport_comments([comment])
    db_session.add(user)
    db_session.commit()

    # Return updated supporters list
    supporters = comment.fetch_supporter_ids()
    app.logger.debug("Updated supporters list==> %s", supporters)
    return jsonify(message="Support removed",
                   supporters=str(supporters),
                   num_supporters = len(supporters)), 201


#
# Get Comments
#
@app.route(
    REST_URL_PREFIX + '/questions/<int:question_id>/proposals/' +
    '<int:proposal_id>/comments',
    methods=['GET'])
@app.route(
    REST_URL_PREFIX + '/questions/<int:question_id>/proposals/' +
    '<int:proposal_id>/comments/<int:comment_id>',
    methods=['GET'])
@requires_auth
def api_get_proposal_comments(question_id, proposal_id, comment_id=None):
    '''
    .. http:get:: /questions/(int:question_id)/proposals/(int:proposal_id)/comments

        A user or list of comments.

        **Example request**:

        .. sourcecode:: http

            GET /questions/45/proposals/47/comments HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
               "total_items": 2,
                "items": "2",
                "comments": [
                    {
                      "comment": "This is terrible!",
                      "generation": "1",
                      "question_url": "/api/v1/questions/1",
                      "author_url": "/api/v1/users/1",
                      "comment_type": "oppose",
                      "created": "2013-10-21 15:43:17.558333",
                      "url": "/api/v1/questions/1/proposals/4/comments/1",
                      "proposal_url": "/api/v1/questions/1/proposals/4",
                      "id": "1"
                    },
                    {
                      "comment": "I feel very confused!",
                      "generation": "1",
                      "question_url": "/api/v1/questions/1",
                      "author_url": "/api/v1/users/3",
                      "comment_type": "confused",
                      "created": "2013-10-21 15:43:17.695875",
                      "url": "/api/v1/questions/1/proposals/4/comments/2",
                      "proposal_url": "/api/v1/questions/1/proposals/4",
                      "id": "2"
                    }
                ]
            }

        :param question_id: question id
        :type question_id: int
        :param proposal_id: proposal id
        :type proposal_id: int
        :param comment_id: comment id
        :type comment_id: int or None
        :statuscode 200: no error
        :statuscode 404: there's no user
    '''
    app.logger.debug("api_get_comments called...\n")

    # Get authenticated user or None
    user = get_authenticated_user(request)
    #if not user:
    #    abort(401)

    if question_id is None or proposal_id is None:
        message = {"message": "Question or proposal ids not set"}
        return jsonify(message), 400

    question = models.Question.query.get(int(question_id))
    if question is None:
        message = {"message": "Question not found"}
        return jsonify(message), 404
    
    # Check if user has permission to view the question
    perm = question.get_permissions(user)
    if not perm:
        app.logger.debug("ACCESS ERROR: User %s tried to access question %s", user.id, question.id)
        return jsonify(message = "You do not have permission to view this question"), 404

    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        message = {"message": "Proposal not found"}
        return jsonify(message), 404

    if comment_id is not None:
        comment = models.Comment.query.get(int(comment_id))
        if comment is None:
            message = {"message": "Comment not found"}
            return jsonify(message), 404

        result = comment.get_public()

        return jsonify(comment=result), 200

    else:
        generation = None
        if generation in request.args:
            generation = int(request.args['generation'])

        app.logger.debug("Get Comments: generation = %s", generation)

        comments = proposal.get_comments(generation)

        items = len(comments)
        total_items = len(comments)

        results = []
        for c in comments:
            results.append(c.get_public())

        return jsonify(total_items=total_items, items=items,
                       comments=results), 200


# Update comment if no other support
#
@app.route(
    REST_URL_PREFIX + '/questions/<int:question_id>/proposals/' +
    '<int:proposal_id>/comments/<int:comment_id>',
    methods=['POST'])
@requires_auth
def api_update_proposal_comment(question_id, proposal_id, comment_id):
    '''
    .. http:post:: /questions/(int:question_id)/proposals/(int:proposal_id)/comments/(int:comment_id)

        Update a comment.

        **Example request**:

        .. sourcecode:: http

            POST /questions/45/proposals/47/comments/77 HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
                 "message": "Comment Updated"
            }

        :param question_id: question ID
        :type question_id: int
        :param proposal_id: proposal ID
        :type proposal_id: int
        :param comment_id: comment ID
        :type comment_id: int
        :json comment_type: one of endorse, oppose or confused
        :json new_comment: text for new comment
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_add_proposal_comment called...\n")

    user = get_authenticated_user(request)
    if not user:
        return jsonify({"message": "User not found"}), 401

    app.logger.debug("Authenticated User = %s\n", user.id)

    if question_id is None or proposal_id is None:
        return jsonify({"message": "Missing parameters"}), 404

    question = models.Question.query.get(int(question_id))
    if question is None:
        return jsonify({"message": "Question not found"}), 400
    
    # Check if user has permission to view the question
    perm = question.get_permissions(user)
    if not perm:
        app.logger.debug("ACCESS ERROR: User %s tried to access question %s", user.id, question.id)
        return jsonify(message = "You do not have permission to view this question"), 404

    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        return jsonify({"message": "Proposal not found"}), 400

    comment = models.Comment.query.get(int(comment_id))
    if comment is None:
        return jsonify(message = "Comment not found"), 400

    # Only the author can edit a comment
    if comment.user_id != user.id:
        return jsonify(message = "Only the author can edit a comment"), 403

    # Make sure there are no other supportes (other than author)
    supporters = comment.supporters.all()
    if len(supporters) != 1 and supporters[0] != user:
        return jsonify(message = "Comment supported by other users cannot be edited."), 403

    app.logger.debug("request.json = %s\n", request.json)

    if not 'comment_type' in request.json or not request.json['comment_type'] in COMMENT_TYPES:
        message = {"message": "comment_type must be one of endorse, oppose or confused"}
        return jsonify(message), 400

    comment_type = request.json['comment_type']

    new_comment_text = None
    if 'new_comment_text' in request.json:
        if request.json['new_comment_text'] == '':
            message = {"message": "Comment text empty"}
            return jsonify(message), 400
        elif len(request.json['new_comment_text']) > MAX_LEN_PROPOSAL_COMMENT:
            message = {"message": "Comment text must be no longer than " + str(MAX_LEN_PROPOSAL_COMMENT) + " characters"}
            return jsonify(message), 400
        else:
            new_comment_text = request.json['new_comment_text']

    app.logger.debug("comment_type = %s\n", comment_type)
    app.logger.debug("new_comment_text = %s\n", new_comment_text)

    # Check if update details are identical to existing details
    if comment_type == comment.comment_type and comment.comment == new_comment_text:
        return jsonify(message = "Update matches original"), 409

    # Check if duplcate comment already exists
    existing_comment = models.Comment.fetch_if_exists(proposal, new_comment_text, comment_type)
    if (existing_comment and existing_comment.id != comment.id):
        return jsonify(message = "Identical comment found"), 400

    # Everything OK - update comment
    comment.comment = new_comment_text
    comment.comment_type = comment_type
    db_session.commit()
    return jsonify(message="Comment updated"), 201


# Add Comment
#
@app.route(
    REST_URL_PREFIX + '/questions/<int:question_id>/proposals/' +
    '<int:proposal_id>/comments',
    methods=['POST'])
@requires_auth
def api_add_proposal_comment(question_id, proposal_id):
    '''
    .. http:post:: /questions/(int:question_id)/proposals/(int:proposal_id)/comments

        Add a comment.

        **Example request**:

        .. sourcecode:: http

            POST /questions/45/proposals/47/comments HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
                 "message": "Comment added"
            }

        :param question_id: question ID
        :type question_id: int
        :param proposal_id: proposal ID
        :type proposal_id: int
        :json comment_type: one of endorse, oppose or confused
        :json new_comment: text for new comment
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_add_proposal_comment called...\n")

    user = get_authenticated_user(request)
    if not user:
        # abort(401)
        message = {"message": "You need to be logged in to post a comment"}
        return jsonify(message), 401

    app.logger.debug("Authenticated User = %s\n", user.id)

    if question_id is None or proposal_id is None:
        abort(404)

    question = models.Question.query.get(int(question_id))
    if question is None:
        message = {"message": "Question not found"}
        return jsonify(message), 400
    
    # Check if user has permission to view the question
    perm = question.get_permissions(user)
    if not perm:
        app.logger.debug("ACCESS ERROR: User %s tried to access question %s", user.id, question.id)
        return jsonify(message = "You do not have permission to view this question"), 404

    # Check if user has permission to write comments
    #elif not models.Question.COMMENT & perm:
    elif not perm in [models.Question.PROPOSE_READ,
                      models.Question.VOTE_READ,
                      models.Question.VOTE_PROPOSE_READ,
                      models.Question.READ_COMMENT]:
        app.logger.debug("ACCESS ERROR: User %s with permission %s tried to write comments on question %s", user.id, perm, question.id)
        return jsonify(message = app.config['QUESTION_COMMENT_PERMISSION_DENIED_MESSAGE']), 400

    # Consider allowing comments during writing
    elif question.phase != 'voting':
        message = {"message": "Adding comments is only allowed during the voting phase"}
        return jsonify(message), 403

    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        message = {"message": "Proposal not found"}
        return jsonify(message), 400

    app.logger.debug("request.json = %s\n", request.json)

    if not 'comment_type' in request.json or not request.json['comment_type'] in COMMENT_TYPES:
            message = {"message": "comment_type must be one of for, against, question or answer"}
            return jsonify(message), 400

    comment_type = request.json['comment_type']

    comment = None
    if 'comment' in request.json:
        if request.json['comment'] == '':
            message = {"message": "Comment text empty"}
            return jsonify(message), 400
        elif len(request.json['comment']) > MAX_LEN_PROPOSAL_COMMENT:
            message = {"message": "Comment text must be no longer than " + str(MAX_LEN_PROPOSAL_COMMENT) + " characters"}
            return jsonify(message), 400
        else:
            comment = request.json['comment']
    else:
        message = {"message": "No comment text passed"}
        return jsonify(message), 400

    reply_to = 0
    if 'reply_to' in request.json:
        try:
            reply_to = int(request.json['reply_to'])
        except:
            app.logger.debug('Failed to convert reply_to param to integer')
            reply_to = 0

    app.logger.debug("comment_type = %s\n", comment_type)
    app.logger.debug("comment = %s\n", comment)
    app.logger.debug("reply_to = %s\n", reply_to)

    # List of supported comments
    comment_id = None
    new_comment = None

    # Fetch the comment which matches comment text or create new one ttt
    if (comment):
        existing_comment = models.Comment.fetch_if_exists(proposal, comment, comment_type)
        if existing_comment:
            message = {"message": "Comment already exists for this proposal"}
            return jsonify(message), 400
        else:
            new_comment = models.Comment(user, proposal, comment, comment_type, reply_to)
            if not new_comment:
                return jsonify(message="Could not create comment"), 500
            else:
                db_session.add(new_comment)
                db_session.commit()
                user.support_comment(new_comment)
                db_session.commit()
                response = new_comment.get_public()
                response['question_count'] = str(proposal.get_question_count())
                response['comment_count'] = proposal.get_comment_count()

                # Add notifiation emails ttt
                app.logger.info('Add notifiation emails...')
                if comment_type == 'question':
                    # Notifiy author
                    app.logger.info('Notifying proposal author ID %s of new question', proposal.author.id)
                    emails.send_new_question_comment_email(question, proposal, new_comment, proposal.author)
                elif comment_type == 'answer':
                    # Notifiy question comment supporters
                    question_comment = models.Comment.query.get(new_comment.reply_to)
                    if not question_comment:
                        app.logger.info('Answer to non-existant question?')
                    else:
                        supporters = question_comment.supporters.all()
                        for user in supporters:
                            if user.id == question_comment.user_id:
                                app.logger.info('Notifying proposal question author ID %s of new answer', user.id)
                                emails.send_new_question_answer_email_to_question_author(question,
                                                                                         proposal,
                                                                                         question_comment,
                                                                                         new_comment,
                                                                                         user)
                            else:
                                app.logger.debug('Notifying proposal question supporter ID %s of new answer', user.id)
                                emails.send_new_question_answer_email(question,
                                                                      proposal,
                                                                      question_comment,
                                                                      new_comment,
                                                                      user)

                return jsonify(comment=response), 201


# Delete comment (if unsupported by anyone else)
@app.route(
    REST_URL_PREFIX + '/questions/<int:question_id>/proposals/' +
    '<int:proposal_id>/comments/<int:comment_id>',
    methods=['DELETE'])
@requires_auth
def api_delete_proposal_comment(question_id, proposal_id, comment_id):
    '''
    .. http:delete:: /questions/(int:question_id)/proposals/(int:proposal_id)/comments/(int:comment_id)

        Delete a comment.

        **Example request**:

        .. sourcecode:: http

            DELETE /questions/45/proposals/47/comments/77 HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
                 "message": "Comment deleted"
            }

        :param question_id: question ID
        :type question_id: int
        :param proposal_id: proposal ID
        :type proposal_id: int
        :param comment_id: comment ID
        :type comment_id: int
        :statuscode 201: no error
        :statuscode 400: bad request
        :statuscode 401: unauthorized
        :statuscode 404: not found
    '''
    app.logger.debug("api_delete_proposal_comment called...\n")

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    app.logger.debug("Authenticated User = %s\n", user.id)

    if question_id is None or proposal_id is None or comment_id is None:
        return jsonify(message = "URI parameters missing"), 400

    question = models.Question.query.get(int(question_id))
    if question is None:
        return jsonify(message = "Question not found"), 404
    
    # Check if user has permission to view the question
    perm = question.get_permissions(user)
    if not perm:
        app.logger.debug("ACCESS ERROR: User %s tried to access question %s", user.id, question.id)
        return jsonify(message = "You do not have permission to view this question"), 404

    # Check if user has permission to write comments
    #elif not models.Question.COMMENT & perm:
    elif not perm in [models.Question.PROPOSE_READ,
                      models.Question.VOTE_READ,
                      models.Question.VOTE_PROPOSE_READ,
                      models.Question.READ_COMMENT]:
        app.logger.debug("ACCESS ERROR: User %s with permission %s tried to write comments on question %s", user.id, perm, question.id)
        return jsonify(message = app.config['QUESTION_COMMENT_PERMISSION_DENIED_MESSAGE']), 400

    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        return jsonify(message = "Proposal not found"), 404

    comment = models.Comment.query.get(int(comment_id))
    if comment is None:
        return jsonify(message = "Comment not found"), 404

    if comment.supporters.count() > 1:
        return jsonify(message = "Comment has other supporters so cannot be deleted"), 404

    # Unsupport comment
    user.unsupport_comments([comment])
    db_session.add(user)
    db_session.commit()

    # Delete comment
    proposal.comments.remove(comment)
    db_session.commit()
    return jsonify(message="Comment deleted"), 201



@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/thresholds', methods=['POST'])
@requires_auth
def api_adjust_threshold(question_id):
    '''
    .. http:post:: /questions/(int:question_id)/thresholds

        Adjust threashold of a question.

        **Example request**:

        .. sourcecode:: http

            POST /questions/33 HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
             "message": "Question thresholds updated"
            }

        :param question_id: question ID
        :type question_id: int
        :json title: question title
        :json blurb: question content
        :json room: question room
        :json minimum_time: minimum time before question can be moved on
        :json maximum_time: maximum time before question is automatically moved on
        :statuscode 201: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_adjust_threshold called...\n")

    user = get_authenticated_user(request)
    if not user:
        response = {"message": "User not authenticated"}
        return jsonify(response), 401

    app.logger.debug("Authenticated User = %s\n", user.id)

    if 'question_id' is None:
        return jsonify(message="Question ID not set"), 404

    question = models.Question.query.get(int(question_id))
    if question is None:
        return jsonify(message="Question does not exist"), 404

    # Check if user has permission to view the question
    perm = question.get_permissions(user)
    if not perm:
        app.logger.debug("ACCESS ERROR: User %s tried to access question %s", user.id, question.id)
        return jsonify(message = "You do not have permission to view this question"), 404

    # Check user is moderator
    if not perm == models.Question.permission_types['MODERATE'] and user.id != question.user_id:
        return jsonify({"message": "Only the question author or moderator can make this request"}), 401

    if not 'thresholds' in request.json and not ('coords' in request.json['thresholds'] or 'set_to_defaults' in request.json['thresholds']):
        message = {"message": "Set Thresholds: No threshold coordinates or set_to_defaults paramters received"}
        return jsonify(message), 403

    # var params = {coords : {mapx: n_cx, mapy: n_cy}};
    # var params = {set_to_defaults: true};

    if 'set_to_defaults' in request.json['thresholds']:
        set_thresholds = {'mapx': 0.5, 'mapy': 0.5}
    else:
        set_thresholds = request.json['thresholds']['coords']
    
    generation = question.generation
    mapx = float(set_thresholds['mapx'])
    mapy = float(set_thresholds['mapy'])
    
    if question.set_thresholds(user, mapx, mapy, generation=generation):
        coords = {"mapx": mapx, "mapy": mapy}
        response = {"message": "Thresholds set", "coords": coords}
        return jsonify(response), 201
    else:
        message = {"message": "Set Thresholds: Unable to change thresholds"}
        return jsonify(message), 403


# Create Endorsement - or vote on a proposal
#
@app.route(
    REST_URL_PREFIX + '/questions/<int:question_id>/proposals/' +
    '<int:proposal_id>/endorsements',
    methods=['POST'])
@requires_auth
def api_add_proposal_endorsement(question_id, proposal_id):
    '''
    .. http:post:: /questions/(int:question_id)/proposals/(int:proposal_id)/endorsements

        Endorse a proposal.

        **Example request**:

        .. sourcecode:: http

            POST /questions/45/proposals/47/endorsements HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
                 "message": "Endorsement added"
            }

        :param question_id: question ID
        :type question_id: int
        :param proposal_id: proposal ID
        :type proposal_id: int
        :json endorsement_type: one of endorse, oppose or confused
        :json comments: ids of supported comments
        :json new_comment: text for new comment
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_add_proposal_endorsement called...\n")

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    app.logger.debug("Authenticated User = %s\n", user.id)

    if question_id is None or proposal_id is None:
        abort(404)

    question = models.Question.query.get(int(question_id))
    if question is None:
        abort(400)

    if question.phase != 'voting':
        message = {"message": "The question is not in the voting phase"}
        return jsonify(message), 403

    # Check user permission: can vote?
    perm = question.get_permissions(user)
    if not perm:
        app.logger.debug("ACCESS ERROR: User %s with permission %s tried to vote on question %s", user.id, perm, question.id)
        return jsonify(message = app.config['QUESTION_PERMISSION_DENIED_MESSAGE']), 400
    
    if not models.Question.VOTE & perm:
        app.logger.debug("ACCESS ERROR: User %s with permission %s tried to vote on question %s", user.id, perm, question.id)
        return jsonify(message = app.config['QUESTION_VOTE_PERMISSION_DENIED_MESSAGE']), 400

    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        abort(400)

    app.logger.debug("request.json = %s\n", request.json)

    '''
    We either use an endorsement type returned from the client to set the endorsement or
    the NORMALISED coordinates from the triangular votemap when compared to the
    threshold for the current generation of this question.
    '''

    # Check if using votemap to calculate endorsement type
    if 'use_votemap' in request.json and request.json['use_votemap']:
        app.logger.debug('Endorsing using votemap coordinates')
        # Check for coords

        if not 'coords' in request.json:
            message = {"message": "Using votemap: No votemap coordinates received"}
            return jsonify(message), 403

        coords = request.json['coords']

        # if not coords['mapx'] or not coords['mapy']:
        if not isinstance(coords['mapx'], (int, float)) or not isinstance(coords['mapy'], (int, float)):
            message = {"message": "Using votemap: No votemap coordinates received"}
            return jsonify(message), 403

        # Calculate endorsement type from coords
        mapx = float(coords['mapx'])
        mapy = float(coords['mapy'])

        # Fetch current threshold coordinates for this generation
        threshold = question.thresholds\
            .filter(models.Threshold.generation == question.generation).first()

        if not threshold:
            app.logger.debug('No threshold found for question! Database out of date?')
            message = {"message": "No threshold was found for this question"}
            return jsonify(message), 500

        if mapy > threshold.mapy:
            endorsement_type = 'confused';
        elif mapx < threshold.mapx:
            endorsement_type = 'oppose';
        else:
            endorsement_type = 'endorse';

        # Add user endorsement
        proposal.endorse(user, endorsement_type, coords=coords)
        db_session.commit()
    else:
        app.logger.debug('Endorsing using supplied endorsement type')
        if not 'endorsement_type' in request.json:
            message = {"message": "You must set endorsement_type if not using votemap coordinates"}
            return jsonify(message), 400
        elif not request.json['endorsement_type'] in ENDORSEMENT_TYPES:
            message = {"message": "endorsement_type must be one of endorse, oppose or confused"}
            return jsonify(message), 400
        else:
            app.logger.debug("Endrsing type json parameter == %s", request.json['endorsement_type'])
            endorsement_type = request.json['endorsement_type']
            # Add user endorsement
            proposal.endorse(user, endorsement_type)
            db_session.commit()

    '''
    # Update graphs
    question.get_voting_graph(
        generation=generation,
        map_type='all')
    question.get_voting_graph(
        generation=generation,
        map_type='all')
    '''

    return jsonify(message="Endorsement added",
                   endorsement_type=endorsement_type,
                   vote_count=str(proposal.get_vote_count())), 201


# Edit proposal V2
#
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/proposals/<int:proposal_id>',
           methods=['POST'])
@requires_auth
def api_edit_proposal(question_id, proposal_id):
    '''
    .. http:post:: questions/(int:question_id)/proposals/(int:proposal_id)

        Edit proposal.

        **Example request**:

        .. sourcecode:: http

            POST questions/22/proposals/14 HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
              "message": "Proposal updated"
            }

        :param question_id: question ID
        :type question_id: int
        :param proposal_id: proposal ID
        :type proposal_id: int
        :json title: title
        :json blurb: question content
        :json abstract: optional abstract
        :statuscode 201: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_edit_proposal v2 called...\n")

    # Must be authenticated
    user = get_authenticated_user(request)
    if not user:
        response = {"message": "User not logged in"}
        return jsonify(response), 400

    if 'question_id' is None or 'proposal_id' is None:
        response = {"message": "Requires Question ID"}
        return jsonify(response), 400
    
    if 'proposal_id' is None:
        response = {"message": "Requires Proposal ID"}
        return jsonify(response), 400

    question = models.Question.query.get(question_id)
    if question is None:
        message = {"message": "Question not found"}
        return jsonify(message), 400
    
    if question.question_type_id not in (1,2):
        console.log("Question has invalid type ID: %s" % question.question_type_id)
        message = {"message": "Question has invalid type ID"}
        return jsonify(message), 400
    
    proposal = models.Proposal.query.get(proposal_id)
    if proposal is None:
        message = {"message": "Proposal not found"}
        return jsonify(message), 400

    if user.id != proposal.user_id:
        message = {"message": "You are not authorized to edit this proposal"}
        return jsonify(message), 403

    num_votes = len(proposal.all_voters(generation=proposal.question.generation))
    if num_votes > 0:
        message = {"message": "This proposal has votes and may no longer be edited"}
        return jsonify(message), 403
        
    request_data = None
    if 'title' in request.form:
        request_data = request.form
    elif 'title' in request.json:
        request_data = request.json
    else:
        return jsonify({"message": "No data uploaded"}), 400

    if not 'title' in request_data or request_data['title'] == ''\
            or len(request_data['title']) > MAX_LEN_PROPOSAL_TITLE:
        return jsonify(message="Proposal title must not be empty and must be less than " + str(MAX_LEN_PROPOSAL_ABSTRACT) + " characters"), 400

    title = request_data['title']
    if question.check_for_duplicate_proposal_title(title, proposal_id):
        return jsonify(message = "A proposal with that title already exists for this question"), 404

    # Update text proposal
    if question.question_type_id == 1:

        if not 'blurb' in request_data or request_data['blurb'] == ''\
                or len(request_data['blurb']) > MAX_LEN_PROPOSAL_BLURB:
            return jsonify(message="Proposal content must not be empty and must be less than " + str(MAX_LEN_PROPOSAL_ABSTRACT) + " characters"), 400

        elif 'abstract' in request_data and \
                len(request_data['abstract']) > MAX_LEN_PROPOSAL_ABSTRACT:
            return jsonify(message="Proposal abstract name must less than " + str(MAX_LEN_PROPOSAL_ABSTRACT) + " characters"), 400

        blurb = request_data.get('blurb')
        if question.check_for_duplicate_proposal_blurb(blurb, proposal_id):
            return jsonify(message = "A proposal with that content already exists for this question"), 404
        
        abstract = request_data.get('abstract', None)

        if proposal.update(user=user, title=title, blurb=blurb, abstract=abstract):
            db_session.commit()
            return jsonify(message="Proposal updated",
                           proposal=proposal.get_public()), 201
        else:
            message = {"message": "There was an error updating this proposal"}
            return jsonify(message), 400

    # Update image proposal
    elif question.question_type_id == 2:

        image_file = None
        # Check if user has uploaded a different image
        if 'image' in request.files:
            image = request.files['image']
            app.logger.debug("Uploaded image = %s", image.filename)

            if not allowed_file(image.filename):
                message = 'image file must be of type: ' + ', '.join(app.config['ALLOWED_EXTENSIONS'])
                return jsonify(message=message, error=message), 401

            use_filename = models.create_image_filename(image.filename, [str(question.id)])
            app.logger.debug("use_filename = %s", use_filename)
            if models.check_user_file_exists(user, use_filename):
                message = 'An image of that name already exists'
                return jsonify(message=message), 401

            image_file = models.save_image(user, image, use_filename)
            #image_file = models.save_image(user, image)

            if image_file == False:
                message = 'Failed to save image. Proposal not updated.'
                return jsonify(message=message, error=message), 401

        proposal.delete_image()
        if proposal.update(user=user, title=title, image_file=image_file):
            db_session.commit()
            return jsonify(message="Proposal updated",
                           proposal=proposal.get_public()), 201
        else:
            message = {"message": "There was an error updating this proposal"}
            return jsonify(message), 400

#
# Add image proposal bang
#
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/upload_image_proposal', methods=['POST'])
@requires_auth
def api_upload_image_proposal(question_id):
    '''
    .. http:post:: questions/(int:question_id)/upload_image_proposal

        Request password reset.

        **Example request**:

        .. sourcecode:: http

            POST /users HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
                "message": "File saved",
                "url": "http://0.0.0.0:8080/static/usercontent/uploads/1/831e44b41f77c66d6f97aa8ee4977275.jpg"
            }

        :form title: proposal title
        :files image: proposal image
        :statuscode 201: no error
        :statuscode 400: bad request
        :statuscode 401: bad request
    '''
    app.logger.debug("upload_image_proposal called.....\n")
    
    # Must be authenticated
    user = get_authenticated_user(request)
    if not user:
        response = {"message": "User not logged in"}
        return jsonify(response), 400
    
    if question_id is None:
        return jsonify({"message": "Parameter question_id not set"}), 404

    question = models.Question.query.get(int(question_id))
    if question is None:
        return jsonify(message = "Question not found"), 404

    # Check user permission: can propose?
    perm = question.get_permissions(user)
    if not perm:
        app.logger.debug("ACCESS ERROR: User %s with permission %s tried to vote on question %s", user.id, perm, question.id)
        return jsonify(message = app.config['QUESTION_PERMISSION_DENIED_MESSAGE']), 400
    
    elif not models.Question.PROPOSE & perm:
        app.logger.debug("ACCESS ERROR: User %s with permission %s tried to vote on question %s", user.id, perm, question.id)
        return jsonify(message = app.config['QUESTION_PROPOSE_PERMISSION_DENIED_MESSAGE']), 400
    
    app.logger.debug("request files %s", request.files)
    app.logger.debug("request files %s", request.files['image'])
    image = request.files['image']
    app.logger.debug("Image: %s", type(image))
    app.logger.debug("image file = %s", image)
    app.logger.debug("image filename = %s", image.filename)
    if not image:
        message = 'Failed to upload file'
        return jsonify(message=message, error=message), 401
    
    if not allowed_file(image.filename):
        message = 'image file must be of type: ' + ', '.join(app.config['ALLOWED_EXTENSIONS'])
        return jsonify(message=message, error=message), 401

    app.logger.info("request data form %s", request.form)
    app.logger.info("request data form %s", request.form['title'])
    
    if not 'title' in request.form or request.form['title'] == ''\
            or len(request.form['title']) > MAX_LEN_PROPOSAL_TITLE:
        return jsonify(message="Proposal title must not be empty and must be less than " + str(MAX_LEN_PROPOSAL_TITLE) + " characters"), 400
    
    title = request.form['title']
    
    use_filename = models.create_image_filename(image.filename, [str(question.id)])
    app.logger.debug("check if hashed use_filename exists ==> %s", use_filename)
    if models.check_user_file_exists(user, use_filename):
        message = 'An image of that name already exists'
        return jsonify(message=message), 401

    #image_file = models.save_image(user, image, [str(question.id)])
    file_saved = models.save_image(user, image, use_filename)

    if file_saved == False:
        message = 'Failed to save image'
        return jsonify(message=message), 401

    proposal = models.Proposal(author=user, question=question, title=title, image=use_filename)
    db_session.add(proposal)
    db_session.commit()
    
    return jsonify(proposal=proposal.get_public()), 201


#
# Create proposal / Add proposal bang
#
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/proposals', methods=['POST'])
@requires_auth
def api_create_proposal(question_id):
    '''
    .. http:post:: /questions/(int:question_id)/proposals

        Create a proposal.

        **Example request**:

        .. sourcecode:: http

            POST /questions/45/proposals HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
                "url": "/api/v1/questions/45/proposals/1"
            }

        :param question_id: question ID
        :type question_id: int
        :json title: proposal title
        :json blurb: proposal content
        :json abstract: proposal abstract
        :json source: parent proposal ID
        :statuscode 201: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_create_proposal called...\n")

    user = get_authenticated_user(request)
    if not user:
        return jsonify(message = "User not logged in"), 404

    app.logger.debug("Authenticated User = %s\n", user.id)

    if question_id is None:
        return jsonify({"message": "Parameter question_id not set"}), 404

    question = models.Question.query.get(int(question_id))
    if question is None:
        return jsonify(message = "Question not found"), 404

    # Check user permission: can propose?
    perm = question.get_permissions(user)
    if not perm:
        app.logger.debug("ACCESS ERROR: User %s with permission %s tried to vote on question %s", user.id, perm, question.id)
        return jsonify(message = app.config['QUESTION_PERMISSION_DENIED_MESSAGE']), 400
    elif not models.Question.PROPOSE & perm:
        app.logger.debug("ACCESS ERROR: User %s with permission %s tried to vote on question %s", user.id, perm, question.id)
        return jsonify(message = app.config['QUESTION_PROPOSE_PERMISSION_DENIED_MESSAGE']), 400

    if not request.json:
        app.logger.debug("Form data not received...\n")
        abort(400)

    if not 'title' in request.json or request.json['title'] == ''\
            or len(request.json['title']) > MAX_LEN_PROPOSAL_TITLE:
        return jsonify(message="Proposal title must not be empty and must be less than " + str(MAX_LEN_PROPOSAL_TITLE) + " characters"), 400

    elif not 'blurb' in request.json or request.json['blurb'] == ''\
            or len(request.json['blurb']) > MAX_LEN_PROPOSAL_BLURB:
        return jsonify(message="Proposal content must not be empty and must be less than " + str(MAX_LEN_PROPOSAL_BLURB) + " characters"), 400

    elif 'abstract' in request.json and \
            len(request.json['abstract']) > MAX_LEN_PROPOSAL_ABSTRACT:
        return jsonify(message="Proposal abstract name must less than " + str(MAX_LEN_PROPOSAL_ABSTRACT) + " characters"), 400

    title = request.json.get('title').strip()
    if question.check_for_duplicate_proposal_title(title):
        return jsonify(message = "A proposal with that title already exists for this question"), 404

    blurb = request.json.get('blurb').strip()
    if question.check_for_duplicate_proposal_blurb(blurb):
        return jsonify(message = "A proposal with that content already exists for this question"), 404

    abstract = request.json.get('abstract', '').strip()

    source = 0
    if 'source' in request.json:
        if not isinstance(request.json['source'], int):
            message = {"message": "source parameter invalid"}
            return jsonify(message), 400
        elif not models.Proposal.query.get(int(request.json['source'])):
            message = {"message": "source proposal not found"}
            return jsonify(message), 400
        else:
            source = request.json['source']

    proposal = models.Proposal(author=user, question=question, title=title, blurb=blurb, abstract=abstract, source=source)
    db_session.add(proposal)
    db_session.commit()

    return jsonify(proposal=proposal.get_public()), 201


#
# Create proposal / Add proposal bang
#
# @app.route(REST_URL_PREFIX + '/questions/<int:question_id>/proposals', methods=['POST'])
@requires_auth
def api_create_proposal_v1(question_id):
    '''
    .. http:post:: /questions/(int:question_id)/proposals

        Create a proposal.

        **Example request**:

        .. sourcecode:: http

            POST /questions/45/proposals HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
                "url": "/api/v1/questions/45/proposals/1"
            }

        :param question_id: question ID
        :type question_id: int
        :json title: proposal title
        :json blurb: proposal content
        :json abstract: proposal abstract
        :json source: parent proposal ID
        :statuscode 201: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_create_proposal called...\n")

    user = get_authenticated_user(request)
    if not user:
        return jsonify(message = "User not logged in"), 404

    app.logger.debug("Authenticated User = %s\n", user.id)

    if question_id is None:
        return jsonify({"message": "Parameter question_id not set"}), 404

    question = models.Question.query.get(int(question_id))
    if question is None:
        return jsonify(message = "Question not found"), 404

    # Check user permission: can propose?
    perm = question.get_permissions(user)
    if not perm:
        app.logger.debug("ACCESS ERROR: User %s with permission %s tried to vote on question %s", user.id, perm, question.id)
        return jsonify(message = app.config['QUESTION_PERMISSION_DENIED_MESSAGE']), 400

    elif not models.Question.PROPOSE & perm:
        app.logger.debug("ACCESS ERROR: User %s with permission %s tried to vote on question %s", user.id, perm, question.id)
        return jsonify(message = app.config['QUESTION_PROPOSE_PERMISSION_DENIED_MESSAGE']), 400

    if not request.json:
        app.logger.debug("Non json request received...\n")
        abort(400)

    if not 'title' in request.json or request.json['title'] == ''\
            or len(request.json['title']) > MAX_LEN_PROPOSAL_TITLE:
        return jsonify(message="Proposal title must not be empty and must be less than " + str(MAX_LEN_PROPOSAL_TITLE) + " characters"), 400

    elif not 'blurb' in request.json or request.json['blurb'] == ''\
            or len(request.json['blurb']) > MAX_LEN_PROPOSAL_BLURB:
        return jsonify(message="Proposal content must not be empty and must be less than " + str(MAX_LEN_PROPOSAL_BLURB) + " characters"), 400

    elif 'abstract' in request.json and \
            len(request.json['abstract']) > MAX_LEN_PROPOSAL_ABSTRACT:
        return jsonify(message="Proposal abstract name must less than " + str(MAX_LEN_PROPOSAL_ABSTRACT) + " characters"), 400

    title = request.json.get('title')
    blurb = request.json.get('blurb')
    abstract = request.json.get('abstract', '')

    source = 0
    if 'source' in request.json:
        if not isinstance(request.json['source'], int):
            message = {"message": "source parameter invalid"}
            return jsonify(message), 400
        elif not models.Proposal.query.get(int(request.json['source'])):
            message = {"message": "source proposal not found"}
            return jsonify(message), 400
        else:
            source = request.json['source']

    proposal = models.Proposal(author=user, question=question, title=title, blurb=blurb, abstract=abstract, source=source)
    db_session.add(proposal)
    db_session.commit()

    return jsonify(proposal=proposal.get_public()), 201


# Delete proposal
#
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/proposals/<int:proposal_id>',
           methods=['DELETE'])
@requires_auth
def api_delete_proposal(question_id, proposal_id):
    '''
    .. http:delete:: questions/(int:question_id)/proposals/(int:proposal_id)

        Delete a proposal.

        **Example request**:

        .. sourcecode:: http

            DELETE questions/34/proposals/77 HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
             "message": "Proposal deleted"
            }

        :param question_id: question id
        :type question_id: int
        :param proposal_id: proposal id
        :type proposal_id: int
        :statuscode 201: no error
        :statuscode 400: bad request
        :statuscode 401: user not authorized
        :statuscode 403: action forbidden
        :statuscode 404: question or proposal not found
    '''
    app.logger.debug("api_delete_proposal called...\n")

    user = get_authenticated_user(request)
    if not user:
        return jsonify(message = "User not found"), 401

    # Check user permission: can vote?
    question = models.Question.query.get(question_id)
    if question is None:
        return jsonify(message = "Question not found"), 404

    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        return jsonify(message = "Proposal %s not found" % int(proposal_id)), 404
    
    if user.id != proposal.user_id:
        message = {"message": "Only the author can delete this proposal"}
        return jsonify(message), 403

    num_votes = len(proposal.all_voters(generation=proposal.question.generation))
    if num_votes > 0:
        message = {"message": "This proposal has votes and may no longer be deleted"}
        return jsonify(message), 403

    '''
    if proposal.question.phase != 'writing'\
            or proposal.question.generation != proposal.generation_created:
        message = {"message": "This proposal may no longer be deleted"}
        return jsonify(message), 403
    '''

    # Delete image if there's one
    proposal.delete_image()

    user.delete_proposal(proposal)
    db_session.commit()
    return jsonify(message="Proposal deleted"), 200


# Delete Question
#
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>', methods=['DELETE'])
@requires_auth
def api_delete_question(question_id):
    '''
    .. http:post:: /questions/(int:question_id)

        Delete a question.

        **Example request**:

        .. sourcecode:: http

            POST /questions/34 HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "message": "Question deleted"
            }

        :param question_id: question ID
        :type question_id: int
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_delete_question called for question %s...\n",
                     question_id)

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    app.logger.debug("Authenticated User = %s\n", user.id)

    if 'question_id' is None:
        abort(404)

    question = models.Question.query.get(int(question_id))
    if question is None:
        abort(404)

    # Cannot delete a question if not author
    if user.id != question.user_id:
        message = {"message":
                   "You are not authorized to delete this question"}
        return jsonify(message), 403

    # Cannot delete a question which has proposals
    if question.proposals.count() > 0:
        message = {"message":
                   "This question has proposals and may no longer be deleted"}
        return jsonify(message), 403

    db_session.delete(question)
    db_session.commit()
    return jsonify(message="Question deleted"), 200


# Finished Writing
#
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/finished_writing', methods=['POST'])
@requires_auth
def api_finished_writing(question_id):
    '''
    .. http:post:: /questions/(int:question_id)/finished_writing

        Indicate that a user has finished writing proposals for this genration of a question.

        **Example request**:

        .. sourcecode:: http

            POST /questions/33//finished_writing HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
             "message": "Writing status updated"
            }

        :param question_id: question ID
        :type question_id: int
        :statuscode 201: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_finished_writing called...\n")

    user = get_authenticated_user(request)
    if not user:
        response = {"message": "User not authenticated"}
        return jsonify(response), 401

    if 'question_id' is None:
        return jsonify(message="Parameter question_id not set"), 404

    question = models.Question.query.get(question_id)
    if question is None:
        return jsonify(message="Question not found"), 404
    
    finished_writing = db_session.query(models.FinishedWriting)\
                .filter(and_(models.FinishedWriting.user_id == user.id,
                             models.FinishedWriting.question_id == question.id,
                             models.FinishedWriting.generation == question.generation))\
                .first()
    
    if finished_writing:
        return jsonify(message="Finished Writing status already set",
                       writing_status=1), 200

    finished_writing = models.FinishedWriting(user=user,
                                              question=question)

    db_session.add(finished_writing)
    db_session.commit()
    return jsonify(message="Writing status updated",
                   writing_status=1), 201

# Delete finished writing status
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/finished_writing', methods=['DELETE'])
@requires_auth
def api_delete_finished_writing(question_id):
    '''
    .. http:delete:: /questions/(int:question_id)/finished_writing

        Indicate that a user has removed his finished writing status for this genration of a question.

        **Example request**:

        .. sourcecode:: http

            DELETE /questions/33//finished_writing HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
             "message": "Writing status updated"
            }

        :param question_id: question ID
        :type question_id: int
        :statuscode 201: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_finished_writing called...\n")

    user = get_authenticated_user(request)
    if not user:
        response = {"message": "User not authenticated"}
        return jsonify(response), 401

    if 'question_id' is None:
        return jsonify(message="Parameter question_id not set"), 404

    question = models.Question.query.get(question_id)
    if question is None:
        return jsonify(message="Question not found"), 404

    finished_writing = db_session.query(models.FinishedWriting)\
                .filter(and_(models.FinishedWriting.user_id == user.id,
                             models.FinishedWriting.question_id == question.id,
                             models.FinishedWriting.generation == question.generation))\
                .first()

    if finished_writing is None:
        return jsonify(message="Finished Writing status already not set",
                       writing_status=0), 200
    
    db_session.delete(finished_writing)
    db_session.commit()
    return jsonify(message="Writing status updated",
                   writing_status=0), 201


# Edit Question
#
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>', methods=['POST'])
@requires_auth
def api_edit_question(question_id):
    '''
    .. http:post:: /questions/(int:question_id)

        Update a question.

        **Example request**:

        .. sourcecode:: http

            POST /questions/33 HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
             "message": "Question updated"
            }

        :param question_id: question ID
        :type question_id: int
        :json title: question title
        :json blurb: question content
        :json room: question room
        :json minimum_time: minimum time before question can be moved on
        :json maximum_time: maximum time before question is automatically moved on
        :statuscode 201: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_edit_question called...\n")

    user = get_authenticated_user(request)
    if not user:
        response = {"message": "User not authenticated"}
        return jsonify(response), 401

    app.logger.debug("Authenticated User = %s\n", user.id)

    if 'question_id' is None:
        return jsonify(message="Question ID not set"), 404

    question = models.Question.query.get(int(question_id))
    if question is None:
        return jsonify(message="Question does not exist"), 404

    user_id = user.id

    # Cannot edit a question if not author
    if user_id != question.user_id:
        message = {"message": "Only the author can edit this question"}
        return jsonify(message), 403

    if 'move_to_results' in request.json:
        question.phase = 'results'
        db_session.commit()
        return jsonify(message="Question now in results phase",
                       phase=question.phase), 200
    
    if 'move_on' in request.json:
        # phase = question.author_move_on(user_id)
        phase = question.move_on(user)

        if not phase:
            return jsonify(message="Server Error - Question could not be moved on"), 500
        else:
            return jsonify({"question": question.get_public()}), 200

    # Cannot edit a question which has proposals
    if question.proposals.count() > 0:
        message = {"message":
                   "This question has proposals and may no longer be edited"}
        return jsonify(message), 405

    if not 'title' in request.json or request.json['title'] == ''\
            or len(request.json['title']) > MAX_LEN_QUESTION_TITLE:
        message = {"message": "Missing or empty title field"}
        return jsonify(message), 400

    elif not 'blurb' in request.json or request.json['blurb'] == ''\
            or len(request.json['blurb']) > MAX_LEN_QUESTION_BLURB:
        message = {"message": "Missing or empty content field"}
        return jsonify(message), 400

    elif not 'question_type' in request.json or 'question_type' in request.json and 'question_type' in request.json and (not isinstance( request.json['question_type'], int )\
         or not request.json['question_type'] in (1,2)):
        return jsonify(message="Invalid or missing parameter question_type"), 400

    elif not 'voting_type' in request.json or 'voting_type' in request.json and (not isinstance( request.json['voting_type'], int )\
         or not request.json['voting_type'] in (1,2)):
        return jsonify(message="Invalid or missing parameter voting_type"), 400

    elif not 'permissions' in request.json or 'permissions' in request.json and (not isinstance( request.json['permissions'], int )\
         or not request.json['permissions'] in models.Question.permission_types.values()):
        return jsonify(message="Invalid or missing parameter permissions"), 400

    # Check link count in blurb
    blurb = request.json.get('blurb')
    num_links = blurb.count('http')
    app.logger.debug("%s links in quetion text", num_links)
    if num_links > app.config['MAX_LINKS_IN_QUESTION']:
        message = "Text contains %s links. Text can contain no more than %s links" % (num_links, app.config['MAX_LINKS_IN_QUESTION'])
        return jsonify(message=message), 400
    elif num_links > app.config['MAX_LINKS_IN_QUESTION_WITHOUT_VALIDATION']: 
        if 'recaptcha' not in request.json or len(request.json['recaptcha']) == 0:
            message = "Text contains %s links. Text containing more than %s links requires validation with recaptcha" % (num_links, app.config['MAX_LINKS_IN_QUESTION_WITHOUT_VALIDATION'])
            return jsonify(message=message), 400
        else:
            import requests
            params = {'secret': app.config['RECAPTCHA_SECRET'], 'response': request.json['recaptcha']}
            r = requests.post(app.config['RECAPTCHA_API_URL'], data=params)
            if not r.ok:
                message = "Text contains %s links. Invalid recaptcha parameter value received." % (num_links)
                return jsonify(message=message), 400
    
    question.blurb = blurb
    question.title = request.json.get('title')
    question.question_type_id = request.json.get('question_type', 1)
    question.voting_type_id = request.json.get('voting_type', 1)

    # Get author permissions - defaults to VOTE_PROPOSE_READ
    author_permissions = int(request.json.get('permissions', models.Question.VOTE_PROPOSE_READ))

    # Update question
    db_session.add(question)
    db_session.commit()

    # Update author permissions
    # user.invites.append(models.Invite(user, user.id, author_permissions, question.id))
    invite = user.invites.filter_by(receiver_id=user.id,question_id=question.id).first()
    invite.permissions = author_permissions
    db_session.commit()

    return jsonify(message="Question updated"), 200


# Edit proposal V1
#
#@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/proposals/<int:proposal_id>',
#         methods=['POST'])
@requires_auth
def api_edit_proposal_v1(question_id, proposal_id):
    '''
    .. http:post:: questions/(int:question_id)/proposals/(int:proposal_id)

        Edit proposal.

        **Example request**:

        .. sourcecode:: http

            POST questions/22/proposals/14 HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
              "message": "Proposal updated"
            }

        :param question_id: question ID
        :type question_id: int
        :param proposal_id: proposal ID
        :type proposal_id: int
        :json title: title
        :json blurb: question content
        :json abstract: optional abstract
        :statuscode 201: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_edit_proposal V1 %s called...\n", proposal_id)

    user = get_authenticated_user(request)
    if not user:
        response = {"message": "User not found"}
        return jsonify(response), 401

    app.logger.debug("Authenticated User = %s\n", user.id)

    if 'question_id' is None or 'proposal_id' is None:
        response = {"message": "Requires Question ID"}
        return jsonify(response), 400
    
    if 'proposal_id' is None:
        response = {"message": "Requires Proposal ID"}
        return jsonify(response), 400
    
    question = models.Question.query.get(int(question_id))
    if question is None:
        response = {"message": "Question not found"}
        return jsonify(response), 400
    
    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        response = {"message": "Proposal not found"}
        return jsonify(response), 400

    if user.id != proposal.user_id:
        message = {"message": "You are not authorized to edit this proposal"}
        return jsonify(message), 403

    num_votes = len(proposal.all_voters(generation=proposal.question.generation))
    if num_votes > 0:
        message = {"message": "This proposal has votes and may no longer be edited"}
        return jsonify(message), 403

    if not 'title' in request.json or request.json['title'] == ''\
            or len(request.json['title']) > MAX_LEN_PROPOSAL_TITLE:
        return jsonify(message="Proposal title must not be empty and must be less than " + str(MAX_LEN_PROPOSAL_ABSTRACT) + " characters"), 400

    elif not 'blurb' in request.json or request.json['blurb'] == ''\
            or len(request.json['blurb']) > MAX_LEN_PROPOSAL_BLURB:
        return jsonify(message="Proposal content must not be empty and must be less than " + str(MAX_LEN_PROPOSAL_ABSTRACT) + " characters"), 400

    elif 'abstract' in request.json and \
            len(request.json['abstract']) > MAX_LEN_PROPOSAL_ABSTRACT:
        return jsonify(message="Proposal abstract name must less than " + str(MAX_LEN_PROPOSAL_ABSTRACT) + " characters"), 400

    title = request.json.get('title')
    blurb = request.json.get('blurb')
    abstract = request.json.get('abstract', None)
    
    # It is OK to update the proposal
    if proposal.update(user, title, blurb, abstract):
        db_session.commit()
        message = {"message": "Proposal updated"}
        return jsonify(message), 200
    else:
        message = {"message": "There was an error updating this proposal"}
        return jsonify(message), 400

# Get users not yet invited to participate in a question
@app.route(REST_URL_PREFIX + '/users/associated_users',
           methods=['GET'])
@requires_auth
def api_associated_users():
    '''
    .. http:get:: /users/associated_users

        A list of associared users not yet invited to participate in a question.

        **Example request**:

        .. sourcecode:: http

            GET /users/2/associated_users HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "query_generation": "1",
              "current_generation": "1",
              "not_invited": [
                {
                  "username": "john",
                  "url": "/users/1",
                  "registered": "2013-08-15 18:10:23.877239",
                  "id": "1",
                  "last_seen": "2013-08-15 18:10:23.877268"
                },
                {
                  "username": "susan",
                  "url": "/users/2",
                  "registered": "2013-08-15 18:10:23.938536",
                  "id": "2",
                  "last_seen": "2013-08-15 18:10:23.938550"
                },
                {
                  "username": "harry",
                  "url": "/users/5",
                  "registered": "2013-08-15 18:10:23.981326",
                  "id": "5",
                  "last_seen": "2013-08-15 18:10:23.981341"
                }
              ],
              "num_items": "3",
              "question_id": "1"
            }

        :param question_id: question id
        :type question_id: int
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_associated_users called...\n")

    user = get_authenticated_user(request)
    if not user:
        return jsonify(message = "User not logged in"), 404

    question_id = request.args.get('ignore_question', None)

    if not question_id:
        message = "You must pass the question ID" %\
                  question_id
        return jsonify(message=message), 401

    app.logger.debug("api_associated_users ignore question with ID %s", question_id)

    # If a question id is given, check it question exists.
    # If not then abort
    question = models.Question.query.get(int(question_id))
    if question is None:
        message = "Question with ID %s does not exist" %\
                  question_id
        return jsonify(message=message), 400

    # Check if user has permission to view the question
    perm = question.get_permissions(user)
    if not perm:
        app.logger.debug("ACCESS ERROR: User %s tried to access question %s", user.id, question.id)
        return jsonify(message = "You do not have permission to view this question"), 404

    #not_invited = user.get_uninvited_associated_users(question=question)
    not_invited = user.get_uninvited_associated_users_by_invitation(question=question)

    return jsonify(question_id=str(question.id),
                   num_items=str(len(not_invited)),
                   not_invited=not_invited), 200


# Decline a new invitation
@app.route(REST_URL_PREFIX + '/users/<int:user_id>/new_invites/<int:invite_id>/decline', methods=['POST'])
@requires_auth
def api_decline_new_invite(user_id, invite_id):
    '''
    .. http:get:: /users/(int:user_id)/new_invites/(int:invite_id)/decline

        Decline an invitation to participate in a question.

        **Example request**:

        .. sourcecode:: http

            GET /questions/42/not_invited HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "invites": [
                {
                  "id": 1, 
                  "permissions": 7, 
                  "question_id": 6, 
                  "question_title": "Is This the Question of Life", 
                  "receiver_id": 2, 
                  "sender_id": 1, 
                  "sender_url": "/api/v2/users/1", 
                  "sender_username": "john"
                }
              ], 
              "num_items": "1"
            }

        :param user_id: user id
        :type user_id: int
        :param invit_id: invitation id
        :type user_id: int
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_not_invited called...\n")

    user = get_authenticated_user(request)
    if not user:
        return jsonify(message = "User not logged in"), 404

    if user_id is None:
        return jsonify(message = "user_id not set"), 404
    
    if invite_id is None:
        return jsonify(message = "invite_id not set"), 404

    new_invitation = models.UserInvite.query.filter_by(id=invite_id).first()
    
    if not new_invitation:
        return jsonify(message = "Invitation not found"), 404
        
    user.new_invites.remove(new_invitation)
    db_session.commit()

    return jsonify(message = "Invitation declined"), 200

# Accept new invitation
@app.route(REST_URL_PREFIX + '/users/<int:user_id>/new_invites/<int:invite_id>/accept', methods=['POST'])
@requires_auth
def api_accept_new_invite(user_id, invite_id):
    '''
    .. http:get:: /users/(int:user_id)/new_invites/(int:invite_id)/accept

        Accept an invitation to participate in a question.

        **Example request**:

        .. sourcecode:: http

            GET /questions/42/not_invited HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "invites": [
                {
                  "id": 1, 
                  "permissions": 7, 
                  "question_id": 6, 
                  "question_title": "Is This the Question of Life", 
                  "receiver_id": 2, 
                  "sender_id": 1, 
                  "sender_url": "/api/v2/users/1", 
                  "sender_username": "john"
                }
              ], 
              "num_items": "1"
            }

        :param user_id: user id
        :type user_id: int
        :param invit_id: invitation id
        :type user_id: int
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_accept_new_invite called...\n")

    user = get_authenticated_user(request)
    if not user:
        return jsonify(message = "User not logged in"), 404

    if user_id is None:
        return jsonify(message = "user_id not set"), 404

    if invite_id is None:
        return jsonify(message = "invite_id not set"), 404

    new_invitation = models.UserInvite.query.filter_by(id=invite_id).first()

    if not new_invitation:
        return jsonify(message = "Invitation not found"), 404

    question = models.Question.query.filter_by(id=new_invitation.question_id).first()

    if not question:
        return jsonify(message = "Question not found"), 404

    sender = models.User.query.get(new_invitation.sender_id)
    if not sender:
        return jsonify(message = "Sender not found"), 404

    user.invites_received.append(models.Invite(sender, user, new_invitation.permissions, new_invitation.question_id))
    user.new_invites.remove(new_invitation)
    db_session.commit()

    # Notify sender of acceptance
    app.logger.debug('api_accept_new_invite: Notify sender of acceptance')
    emails.send_user_invite_accepted_email(sender, user, question)

    return jsonify(message = "Invitation accepted"), 200

# Get new invitations
@app.route(REST_URL_PREFIX + '/users/<int:user_id>/new_invites', methods=['GET'])
@requires_auth
def api_new_invites(user_id):
    '''
    .. http:get:: /users/(int:user_id)/new_invites

        A list of new invitations to participate in questions.

        **Example request**:

        .. sourcecode:: http

            GET /questions/42/not_invited HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "invites": [
                {
                  "id": 1, 
                  "permissions": 7, 
                  "question_id": 6, 
                  "question_title": "Is This the Question of Life", 
                  "receiver_id": 2, 
                  "sender_id": 1, 
                  "sender_url": "/api/v2/users/1", 
                  "sender_username": "john"
                }
              ], 
              "num_items": "1"
            }

        :param user_id: user id
        :type user_id: int
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_not_invited called...\n")

    user = get_authenticated_user(request)
    if not user:
        return jsonify(message = "User not logged in"), 404

    if user_id is None:
        return jsonify(message = "user_id not set"), 404

    new_invitations = user.new_invites.all()

    invites = []
    for invite in new_invitations:
        invites.append(invite.get_public())

    return jsonify(num_items=len(invites),
                   invites=invites), 200


# Get users not yet invited to participate in a question
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/not_invited',
           methods=['GET'])
@requires_auth
def api_not_invited(question_id):
    '''
    .. http:get:: /questions/(int:question_id)/not_invited

        A list of users not yet invited to participate in a question.

        **Example request**:

        .. sourcecode:: http

            GET /questions/42/not_invited HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "query_generation": "1",
              "current_generation": "1",
              "endorsers": [
                {
                  "username": "john",
                  "url": "/users/1",
                  "registered": "2013-08-15 18:10:23.877239",
                  "id": "1",
                  "last_seen": "2013-08-15 18:10:23.877268"
                },
                {
                  "username": "susan",
                  "url": "/users/2",
                  "registered": "2013-08-15 18:10:23.938536",
                  "id": "2",
                  "last_seen": "2013-08-15 18:10:23.938550"
                },
                {
                  "username": "harry",
                  "url": "/users/5",
                  "registered": "2013-08-15 18:10:23.981326",
                  "id": "5",
                  "last_seen": "2013-08-15 18:10:23.981341"
                }
              ],
              "num_items": "3",
              "question_id": "1"
            }

        :param question_id: question id
        :type question_id: int
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_not_invited called...\n")

    user = get_authenticated_user(request)
    if not user:
        return jsonify(message = "User not logged in"), 404

    if question_id is None:
        return jsonify({"message": "Parameter question_id not set"}), 404

    question = models.Question.query.get(int(question_id))
    if question is None:
        return jsonify(message = "Question not found"), 404

    # Check if user has permission to view the question
    perm = question.get_permissions(user)
    if not perm:
        app.logger.debug("ACCESS ERROR: User %s tried to access question %s", user.id, question.id)
        return jsonify(message = "You do not have permission to view this question"), 404

    not_invited = user.get_uninvited_associated_users(question)

    return jsonify(question_id=str(question.id),
                   num_items=str(len(not_invited)),
                   not_invited=not_invited), 200


# Get Question Participants
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/permissions',
           methods=['GET'])
@requires_auth
def api_get_question_participants(question_id):
    '''
    .. http:get:: /questions/(int:question_id)/permissions

        A list of question invitee permissions.

        **Example request**:

        .. sourcecode:: http

            GET /questions/42/proposals/67/permissions HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "query_generation": "1",
              "current_generation": "1",
              "endorsers": [
                {
                  "username": "john",
                  "url": "/users/1",
                  "registered": "2013-08-15 18:10:23.877239",
                  "id": "1",
                  "last_seen": "2013-08-15 18:10:23.877268"
                },
                {
                  "username": "susan",
                  "url": "/users/2",
                  "registered": "2013-08-15 18:10:23.938536",
                  "id": "2",
                  "last_seen": "2013-08-15 18:10:23.938550"
                },
                {
                  "username": "harry",
                  "url": "/users/5",
                  "registered": "2013-08-15 18:10:23.981326",
                  "id": "5",
                  "last_seen": "2013-08-15 18:10:23.981341"
                }
              ],
              "num_items": "3",
              "question_id": "1"
            }

        :param question_id: question id
        :type question_id: int
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_get_question_participants called...\n")
    
    user = get_authenticated_user(request)
    if not user:
        return jsonify(message = "User not logged in"), 404

    if question_id is None:
        
        return jsonify({"message": "Parameter question_id not set"}), 404

    question = models.Question.query.get(int(question_id))
    if question is None:
        return jsonify({"message": "Question not found"}), 401
    
    # Check if user has permission to view the question
    perm = question.get_permissions(user)
    if not perm:
        app.logger.debug("ACCESS ERROR: User %s tried to access question %s", user.id, question.id)
        return jsonify(message = "You do not have permission to view this question"), 404

    permissions = question.get_participant_permissions()
    invitations_sent = user.get_invitations_sent(question)
    email_invitations_sent = user.get_email_invitations_sent(question)

    return jsonify(question_id=question.id,
                   num_items=len(permissions),
                   permissions=permissions,
                   invitations_sent=invitations_sent,
                   email_invitations_sent=email_invitations_sent), 200

# Get Proposal Endorsers
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/proposals/' +
           '<int:proposal_id>/endorsers',
           methods=['GET'])
@requires_auth
def api_get_question_proposal_endorsers(question_id, proposal_id):
    '''
    .. http:get:: /questions/(int:question_id)/proposals/(int:proposal_id)/endorsers

        A list of proposal endorsers.

        **Example request**:

        .. sourcecode:: http

            GET /questions/42/proposals/67/endorsers HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "query_generation": "1",
              "current_generation": "1",
              "endorsers": [
                {
                  "username": "john",
                  "url": "/users/1",
                  "registered": "2013-08-15 18:10:23.877239",
                  "id": "1",
                  "last_seen": "2013-08-15 18:10:23.877268"
                },
                {
                  "username": "susan",
                  "url": "/users/2",
                  "registered": "2013-08-15 18:10:23.938536",
                  "id": "2",
                  "last_seen": "2013-08-15 18:10:23.938550"
                },
                {
                  "username": "harry",
                  "url": "/users/5",
                  "registered": "2013-08-15 18:10:23.981326",
                  "id": "5",
                  "last_seen": "2013-08-15 18:10:23.981341"
                }
              ],
              "num_items": "3",
              "question_id": "1"
            }

        :param question_id: question id
        :type question_id: int
        :param proposal_id: proposal id
        :type proposal_id: int
        :query generation: question generation, default is 1
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_get_question_proposal_endorsers called...\n")

    # Check user is logged in
    user = get_authenticated_user(request)
    if user is None:
        return jsonify(message = "User not logged in"), 404
    
    if question_id is None or proposal_id is None:
        app.logger.debug("ERROR: question_id or proposal_id is None!\n")
        return jsonify({"message": "Parameter qustion_id not set"}), 401

    question = models.Question.query.get(int(question_id))
    if question is None:
        return jsonify({"message": "Question not found"}), 401
        
    # Check if user has permission to view the question
    perm = question.get_permissions(user)
    if not perm:
        app.logger.debug("ACCESS ERROR: User %s tried to access question %s", user.id, question.id)
        return jsonify(message = "You do not have permission to view this question"), 404

    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        return jsonify({"message": "Proposal not found"}), 401

    generation = int(request.args.get('generation', question.generation))
    endorsers = proposal.endorsers(generation=generation)

    results = []
    for e in endorsers:
        results.append(e.get_public())

    return jsonify(question_id=str(question.id),
                   query_generation=str(generation),
                   current_generation=str(question.generation),
                   num_items=str(len(endorsers)), endorsers=results), 200


#
# Get Pareto Front
#
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/pareto', methods=['GET'])
@requires_auth
def api_question_pareto(question_id=None):
    '''
    .. http:post:: /questions/(int:question_id)/pareto

        The pareto front of a question. Order by voting preference.

        **Example request**:

        .. sourcecode:: http

            POST /questions/44/proposals HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "query_generation": "1",
              "current_generation": "1",
              "proposals": [
                {
                  "question_url": "/api/v1/questions/1",
                  "author_url": "/api/v1/users/3",
                  "title": "Bills Second Proposal",
                  "url": "/api/v1/questions/1/proposals/2",
                  "abstract": "This is too abstract for an abstract",
                  "created": "2013-08-15 18:32:00.176816",
                  "id": "2",
                  "blurb": "Bills blurb of varying disinterest",
                  "generation_created": "1"
                },
                {
                  "question_url": "/api/v1/questions/1",
                  "author_url": "/api/v1/users/2",
                  "title": "Susans Only Proposal",
                  "url": "/api/v1/questions/1/proposals/3",
                  "abstract": "Blah blah blah",
                  "created": "2013-08-15 18:32:00.194978",
                  "id": "3",
                  "blurb": "My blub is cool",
                  "generation_created": "1"
                },
                {
                  "question_url": "/api/v1/questions/1",
                  "author_url": "/api/v1/users/5",
                  "title": "Harrys Cooler Proposal",
                  "url": "/api/v1/questions/1/proposals/4",
                  "abstract": null,
                  "created": "2013-08-15 18:32:00.228671",
                  "id": "4",
                  "blurb": "Harry edits like a champ",
                  "generation_created": "1"
                }
              ],
              "num_items": "3",
              "question_id": "1"
            }

        :param question_id: question id
        :json username: username
        :json email: email address
        :json password: password
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_question_pareto called with %s...\n", question_id) # final winners
    
    user = get_authenticated_user(request)

    if question_id is None:
        
        return jsonify({"message": "Parameter question_id not set"}), 404

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        return jsonify({"message": "Question not found"}), 404


    # Check if user has permission to view the question
    perm = question.get_permissions(user)
    if not perm:
        app.logger.debug("ACCESS ERROR: User %s tried to access question %s", user.id, question.id)
        return jsonify(message = "You do not have permission to view this question"), 404

    generation = int(request.args.get('generation', question.generation))
    pareto = question.calculate_pareto_front(generation=generation)
    pareto_list = list(pareto)
    pareto_list_sorted = sorted(pareto_list, key=lambda x: x.geomedx, reverse=True)

    results = []
    for p in pareto_list_sorted:
        results.append(p.get_public(user))

    app.logger.debug('pareto data ====> %s', results)

    return jsonify(question_id=str(question.id),
                   query_generation=str(generation),
                   current_generation=str(question.generation),
                   num_items=str(len(pareto)),
                   proposals=results), 200


@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/results', methods=['GET'])
@requires_auth
def api_question_results(question_id=None):
    '''
    .. http:post:: /questions/(int:question_id)/results

        The final results for this question.

        **Example request**:

        .. sourcecode:: http

            POST /questions/44/results HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "current_generation": "1", 
              "results": [
                {
                  "medx": 0.640694,
                  "medy": 0.395, 
                  "author": "bill", 
                  "relations": 
                  {
                    "dominated": [], 
                    "pareto": true, 
                    "dominating": [2, 4], 
                    "understood": false
                  }, 
                  "title": "Bills First Proposal"
                }, 
                {
                  "medx": 0.625, 
                  "medy": 0.175, 
                  "author": "susan", 
                  "relations": 
                  {
                    "dominated": [], 
                    "pareto": true, 
                    "dominating": [], 
                    "understood": true
                  }, 
                  "title": "Susans Only Proposal"
                }
              ], 
              "question_id": "44"
            }

        :param question_id: question id
        :statuscode 200: no error
        :statuscode 404: bad request
    '''
    app.logger.debug("api_question_results called with questiobn ID %s...\n",
                     question_id) # final
    
    user = get_authenticated_user(request)
    if user is None:
        return jsonify(message = "User not logged in"), 404
    
    if question_id is None:
        
        jsonify(message="Question ID not set in request"), 404

    question = models.Question.query.get(int(question_id))
    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        jsonify(message="Question not found"), 404

    # Check if user has permission to view the question
    perm = question.get_permissions(user)
    if not perm:
        app.logger.debug("ACCESS ERROR: User %s tried to access question %s", user.id, question.id)
        return jsonify(message = "You do not have permission to view this question"), 404

    if not question.phase is 'results':
        app.logger.debug("ERROR: Question must be in results phase before returning the results!\n")
        jsonify(message="Question not in results phase"), 404

    results = list()
    all_relations = question.calculate_proposal_relation_ids()
    endorsement_results = question.get_endorsement_results()

    for (proposal_id, relations) in all_relations.iteritems():
        if relations['pareto']:
            proposal = models.Proposal.query.get(proposal_id)
            relations['dominated'] = list(relations['dominated'])
            relations['dominating'] = list(relations['dominating'])
            results.append({'relations': relations, 
                            'medx': endorsement_results[proposal_id]['median']['medx'],
                            'medy': endorsement_results[proposal_id]['median']['medy'],
                            'title': proposal.title,
                            'author': proposal.author.username})
                                    
    '''
    votes = question.all_votes_by_type()
    for (proposal_id, all_votes) in votes.iteritems():
        results[proposal_id] = dict()
        results[proposal_id]['votes'] = all_votes
    '''
    
    app.logger.debug("final results: %s", results)
    
    return jsonify(question_id=str(question.id),
                   current_generation=str(question.generation),
                   results=results), 200



@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/mod_participation_table', methods=['GET'])
@requires_auth
def api_mod_question_participation_table(question_id):
    '''
    .. http:post:: /questions/(int:question_id)/mod_participation_table

        Participation table.

        **Example request**:

        .. sourcecode:: http

            POST /questions/44/key_players HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "query_generation": "1",
              "current_generation": "1",
              "key_players": [
                {
                  "3": [
                    "/api/v1/questions/1/proposals/4",
                    "/api/v1/questions/1/proposals/3"
                  ]
                },
                {
                  "4": [
                    "/api/v1/questions/1/proposals/3"
                  ]
                }
              ],
              "num_items": "2",
              "question_id": "1"
            }

        :param question_id: question id
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_mod_question_participation_table called with %s...\n", question_id)

    user = get_authenticated_user(request)
    if user is None:
        return jsonify(message = "User not logged in"), 404
    
    if question_id is None:
        return jsonify({"message": "Parameter question_id not set"}), 404

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        jsonify(message="Question not found"), 404

    # Check if user has permission to view the question
    perm = question.get_permissions(user)
    if not perm:
        app.logger.debug("ACCESS ERROR: User %s tried to access question %s", user.id, question.id)
        return jsonify(message = "You do not have permission to view this question"), 404

    # Check user is moderator
    if not perm == models.Question.permission_types['MODERATE'] :
        return jsonify({"message": "Only the question moderator can make this request"}), 401

    participants = question.get_participants()
    app.logger.debug("participants==> %s", participants)
    all_proposals = question.get_current_proposals()

    authors = dict()
    for proposal in all_proposals:
        if proposal.author.id not in authors:
            authors[proposal.author.id] = 1
        else:
            authors[proposal.author.id] = authors[proposal.author.id] + 1
    
    '''
    participants
    [{'permissions': '7', 'user_id': '1', 'username': u'john'},
     {'permissions': '7', 'user_id': '2', 'username': u'susan'},
     {'permissions': '7', 'user_id': '3', 'username': u'bill'},
     {'permissions': '7', 'user_id': '4', 'username': u'jack'}]
     
     all_proposals
     [<Proposal(9 'Bill's stuff' by bill, Q:'2')>,
     <Proposal(10 'dfsdfsdfds' by bill, Q:'2')>]
     
     authors
     {1: 1, 2: 0}
     
     {"num_proposals": "2", "current_generation": "1", "question_id": "2", "num_items": "1", 
     "participation_table": [{"username": "bill", "past_generations": 0, "evaluations": 0}]}
     
     {"num_proposals": "2", "current_generation": "1", "question_id": "2", "num_items": "1", 
     "participation_table": [
        {"username": "bill", "evaluations": 0, "authored": 2}
        {"username": "john", "evaluations": 0, "authored": 0}
        {"username": "jack", "evaluations": 0, "authored": 1}
     ]}
    '''
    finished_writing = db_session.query(models.FinishedWriting.user_id)\
                .filter(and_(models.FinishedWriting.question_id == question.id,
                             models.FinishedWriting.generation == question.generation))\
                .all()
    app.logger.debug("participation_table: Finished writing = %s", finished_writing)

    finished = list()
    for row in finished_writing:
        finished.append(row.user_id)

    participation_table = []
    for user in participants:
        participant = dict()
        participant['username'] = user.username
        participant['evaluations'] = user.get_endorsement_count(question)
        
        if user.id not in authors:
            participant['proposals_written'] = 0
        else:
            participant['proposals_written'] = authors[user.id]
        
        if user.id in finished:
            participant['finished_writing'] = 1
        else:
            participant['finished_writing'] = 0
        
        app.logger.debug("participant==>%s", participant)
        participation_table.append(participant)
        app.logger.debug("participation_table==>%s", participation_table)

    return jsonify(question_id=str(question.id),
                   current_generation=str(question.generation),
                   num_proposals=str(len(all_proposals)),
                   num_items=str(len(participation_table)),
                   participation_table=participation_table), 200


@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/participation_table', methods=['GET'])
@requires_auth
def api_question_participation_table(question_id=None):
    '''
    .. http:post:: /questions/(int:question_id)/participation_table

        A list of the Key Players for this round.

        **Example request**:

        .. sourcecode:: http

            POST /questions/44/key_players HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "query_generation": "1",
              "current_generation": "1",
              "key_players": [
                {
                  "3": [
                    "/api/v1/questions/1/proposals/4",
                    "/api/v1/questions/1/proposals/3"
                  ]
                },
                {
                  "4": [
                    "/api/v1/questions/1/proposals/3"
                  ]
                }
              ],
              "num_items": "2",
              "question_id": "1"
            }

        :param question_id: question id
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_question_participation_table called with %s...\n",
                     question_id)

    user = get_authenticated_user(request)
    if user is None:
        return jsonify(message = "User not logged in"), 404
    
    if question_id is None:
        
        return jsonify({"message": "Parameter question_id not set"}), 404

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        jsonify(message="Question not found"), 404

    # Check if user has permission to view the question
    perm = question.get_permissions(user)
    if not perm:
        app.logger.debug("ACCESS ERROR: User %s tried to access question %s", user.id, question.id)
        return jsonify(message = "You do not have permission to view this question"), 404

    # Check user is question author or moderator
    if not perm == models.Question.permission_types['MODERATE'] and not question.user_id == user.id:
        return jsonify({"message": "Only the question author or moderator can make this request"}), 401

    participants = question.get_participants()
    app.logger.debug("participants==> %s", participants)
    all_proposals = question.get_current_proposals()

    authors = dict()
    for proposal in all_proposals:
        if proposal.author.id not in authors:
            authors[proposal.author.id] = 1
        else:
            authors[proposal.author.id] = authors[proposal.author.id] + 1
    
    '''
    participants
    [{'permissions': '7', 'user_id': '1', 'username': u'john'},
     {'permissions': '7', 'user_id': '2', 'username': u'susan'},
     {'permissions': '7', 'user_id': '3', 'username': u'bill'},
     {'permissions': '7', 'user_id': '4', 'username': u'jack'}]
     
     all_proposals
     [<Proposal(9 'Bill's stuff' by bill, Q:'2')>,
     <Proposal(10 'dfsdfsdfds' by bill, Q:'2')>]
     
     authors
     {1: 1, 2: 0}
     
     {"num_proposals": "2", "current_generation": "1", "question_id": "2", "num_items": "1", 
     "participation_table": [{"username": "bill", "past_generations": 0, "evaluations": 0}]}
     
     {"num_proposals": "2", "current_generation": "1", "question_id": "2", "num_items": "1", 
     "participation_table": [
        {"username": "bill", "evaluations": 0, "authored": 2}
        {"username": "john", "evaluations": 0, "authored": 0}
        {"username": "jack", "evaluations": 0, "authored": 1}
     ]}
    '''
    finished_writing = db_session.query(models.FinishedWriting.user_id)\
                .filter(and_(models.FinishedWriting.question_id == question.id,
                             models.FinishedWriting.generation == question.generation))\
                .all()
    app.logger.debug("participation_table: Finished writing = %s", finished_writing)

    finished = list()
    for row in finished_writing:
        finished.append(row.user_id)

    participation_table = []
    for user in participants:
        participant = dict()
        participant['username'] = user.username
        participant['evaluations'] = user.get_endorsement_count(question)
        
        if user.id not in authors:
            participant['proposals_written'] = 0
        else:
            participant['proposals_written'] = authors[user.id]
        
        if user.id in finished:
            participant['finished_writing'] = 1
        else:
            participant['finished_writing'] = 0
        
        app.logger.debug("participant==>%s", participant)
        participation_table.append(participant)
        app.logger.debug("participation_table==>%s", participation_table)

    return jsonify(question_id=str(question.id),
                   current_generation=str(question.generation),
                   num_proposals=str(len(all_proposals)),
                   num_items=str(len(participation_table)),
                   participation_table=participation_table), 200


@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/key_players', methods=['GET'])
@requires_auth
def api_question_key_players(question_id=None):
    '''
    .. http:post:: /questions/(int:question_id)/key_players

        A list of the Key Players for this round.

        **Example request**:

        .. sourcecode:: http

            POST /questions/44/key_players HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "query_generation": "1",
              "current_generation": "1",
              "key_players": [
                {
                  "3": [
                    "/api/v1/questions/1/proposals/4",
                    "/api/v1/questions/1/proposals/3"
                  ]
                },
                {
                  "4": [
                    "/api/v1/questions/1/proposals/3"
                  ]
                }
              ],
              "num_items": "2",
              "question_id": "1"
            }

        :param question_id: question id
        :json username: username
        :json email: email address
        :json password: password
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_question_key_players called with %s...\n",
                     question_id)

    user = get_authenticated_user(request)
    if user is None:
        return jsonify(message = "User not logged in"), 404

    if question_id is None:
        return jsonify({"message": "Parameter question_id not set"}), 404

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        jsonify(message="Question not found"), 404
    
    # Check if user has permission to view the question
    perm = question.get_permissions(user)
    if not perm:
        app.logger.debug("ACCESS ERROR: User %s tried to access question %s", user.id, question.id)
        return jsonify(message = "You do not have permission to view this question"), 404

    generation = int(request.args.get('generation', question.generation))
    key_players = question.calculate_key_players(generation=generation)

    app.logger.debug("calculate_key_players returned: %s", key_players)
    # {3: set([<Proposal('3', Q:'1')>, <Proposal('4', Q:'1')>]), 4: set([<Proposal('3', Q:'1')>])}

    results = []
    for (endorser, vote_for) in key_players.iteritems():
        # Need to initialize values to stop knockout.js complaining
        proposals = {'notvoted': [], 'oppose': [], 'confused': []}
        for proposal in vote_for:
            endorse_type = proposal.get_endorsement_type(endorser)
            # if endorse_type not in proposals:
                # proposals[endorse_type] = list()
            proposals[endorse_type].append(proposal.id)
        kp = {'user': endorser.get_public(), 'add_vote': proposals}
        results.append(kp)

    return jsonify(question_id=str(question.id),
                   query_generation=str(generation),
                   current_generation=str(question.generation),
                   num_items=str(len(key_players)), key_players=results), 200


@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/endorser_effects',
           methods=['GET'])
@requires_auth
def api_question_endorser_effects(question_id=None):
    '''
    .. http:post:: /questions/(int:question_id)/endorser_effects

        A list of endorser effects.

        **Example request**:

        .. sourcecode:: http

            POST /questions/44/endorser_effects HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "query_generation": "1",
              "current_generation": "1",
              "objects": [
                {
                  "5": {}
                },
                {
                  "4": {
                    "PF_excluding": [
                      {
                        "question_url": "/api/v1/questions/1",
                        "author_url": "/api/v1/users/2",
                        "title": "Susans Only Proposal",
                        "url": "/api/v1/questions/1/proposals/3",
                        "abstract": "Blah blah blah",
                        "created": "2013-08-15 18:32:00.194978",
                        "id": "3",
                        "blurb": "My blub is cool",
                        "generation_created": "1"
                      }
                    ],
                    "PF_plus": [],
                    "PF_minus": [
                      {
                        "question_url": "/api/v1/questions/1",
                        "author_url": "/api/v1/users/5",
                        "title": "Harrys Cooler Proposal",
                        "url": "/api/v1/questions/1/proposals/4",
                        "abstract": null,
                        "created": "2013-08-15 18:32:00.228671",
                        "id": "4",
                        "blurb": "Harry edits like a champ",
                        "generation_created": "1"
                      }
                    ]
                  }
                },
                {
                  "3": {
                    "PF_excluding": [
                      {
                        "question_url": "/api/v1/questions/1",
                        "author_url": "/api/v1/users/5",
                        "title": "Harrys Cooler Proposal",
                        "url": "/api/v1/questions/1/proposals/4",
                        "abstract": null,
                        "created": "2013-08-15 18:32:00.228671",
                        "id": "4",
                        "blurb": "Harry edits like a champ",
                        "generation_created": "1"
                      }
                    ],
                    "PF_plus": [],
                    "PF_minus": [
                      {
                        "question_url": "/api/v1/questions/1",
                        "author_url": "/api/v1/users/3",
                        "title": "Bills Second Proposal",
                        "url": "/api/v1/questions/1/proposals/2",
                        "abstract": "This is too abstract for an abstract",
                        "created": "2013-08-15 18:32:00.176816",
                        "id": "2",
                        "blurb": "Bills blurb of varying disinterest",
                        "generation_created": "1"
                      }
                    ]
                  }
                },
                {
                  "1": {}
                }
              ],
              "num_items": "5",
              "question_id": "1"
            }

        :json username: username
        :json email: email address
        :json password: password
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_question_endorser_effects called with %s...\n",
                     question_id)

    user = get_authenticated_user(request)
    if user is None:
        return jsonify(message = "User not logged in"), 404
    
    if question_id is None:
        
        return jsonify({"message": "Parameter question_id not set"}), 404

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        return jsonify({"message": "Question not found"}), 401
    
    # Check if user has permission to view the question
    perm = question.get_permissions(user)
    if not perm:
        app.logger.debug("ACCESS ERROR: User %s tried to access question %s", user.id, question.id)
        return jsonify(message = "You do not have permission to view this question"), 404

    generation = int(request.args.get('generation', question.generation))
    endorser_effects = question.\
        calculate_endorser_effects(generation=generation)

    app.logger.debug("Endorser Effects==> %s", endorser_effects)

    results = []
    for (endorser, effects) in endorser_effects.iteritems():
        endorser_effects = dict()

        if not effects is None:
            PF_excluding_pulbic = replaceWithPublic(effects['PF_excluding'])
            PF_plus_public = replaceWithPublic(effects['PF_plus'])
            PF_minus_public = replaceWithPublic(effects['PF_minus'])

            endorser_effects = {
                'PF_excluding': PF_excluding_pulbic,
                'PF_plus': PF_plus_public,
                'PF_minus': PF_minus_public}
        else:
            endorser_effects = {}

        results.append({endorser.id: endorser_effects})

    return jsonify(question_id=str(question.id),
                   query_generation=str(generation),
                   current_generation=str(question.generation),
                   num_items=str(len(results)), objects=results), 200


def replaceWithPublic(collection):
    public = []
    for c in collection:
        public.append(c.get_public())
    return public


#
# Get graph
#
# http://[hostname]/api/v1.0/questions/47/graph?generation=2&map_type=pareto
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/graph', methods=['GET'])
@requires_auth
def api_question_graph(question_id):
    '''
    .. http:get:: questions/(int:question_id)/graph

        Get the Voting map for this generation.

        **Example request**:

        .. sourcecode:: http

              GET /questions/42/graph?graph_type=pareto&genration=3 HTTP/1.1
              Host: example.com
              Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
             "question_id": 42,
             "graph_generation": 3,
             "graph_type": "all",
             "current_generation": 4,
             "url": "/maps/map_Q42_G4_all_1_1.svg"
            }

        :param question_id: question ID
        :type question_id: int
        :query map_type: map type. default is all generation proposals
        :type map_type: string: either "all" or "pareto", defaults to "all"
        :query generation: question generation
        :type generation: int
        :query proposal_level_type: proposal node layout, defaults to "layers"
        :type proposal_level_type: string: one of "layers", "num_votes" or "flat"
        :query user_level_type: user node layout, defaults to "layers"
        :type user_level_type: string: one of "layers", "num_votes" or "flat"

        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_question_graph called...\n")
    
    user = get_authenticated_user(request)
    if user is None:
        return jsonify(message = "User not logged in"), 404

    if question_id is None:
        return jsonify({"message": "Parameter question_id not set"}), 404

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        return jsonify({"message": "Question not found"}), 401
    
    # Check if user has permission to view the question
    perm = question.get_permissions(user)
    if not perm:
        app.logger.debug("ACCESS ERROR: User %s tried to access question %s", user.id, question.id)
        return jsonify(message = "You do not have permission to view this question"), 404

    generation = int(request.args.get('generation', question.generation))

    # set Algorithm version
    algorithm = int(request.args.get('algorithm', app.config['ALGORITHM_VERSION']))

    app.logger.debug("api_question_graph: ************** USING ALGORITHM %s ************", algorithm)

    # app.logger.debug('Question has %s endorsememnts', question.has_endorsememnts(generation))
    if not question.has_endorsememnts(generation=generation):
        app.logger.debug("Question has no endorsements in generation %s", generation)
        return jsonify(message="No endorsements yet"), 204

    map_type = request.args.get('map_type', 'all')
    proposal_level_type = request.args.get('proposal_level_type',
                                           models.GraphLevelType.layers)
    user_level_type = request.args.get('user_level_type',
                                       models.GraphLevelType.layers)

    '''
    filename_hashed = models.make_map_filename_hashed(question=question,
                                                      generation=generation,
                                                      map_type=map_type,
                                                      proposal_level_type=proposal_level_type,
                                                      user_level_type=user_level_type)
    app.logger.debug('filename_hashed ==> %s', filename_hashed)'''

    app.logger.debug("Call get_voting_graph()...")


    if algorithm == 1:
        graph_svg = question.get_voting_graph(
            generation=generation,
            map_type=map_type,
            proposal_level_type=proposal_level_type,
            user_level_type=user_level_type)
    else:
        graph_svg = question.get_complex_voting_graph(
            generation=generation)

    if not graph_svg:
        message = "There was a problem creating the graph"
        return jsonify(message=message), 500

    return jsonify(question_id=str(question.id),
                   map_type=map_type,
                   graph_generation=str(generation),
                   current_generation=str(question.generation),
                   url=app.config['PROTOCOL'] + app.config['SITE_DOMAIN'] + '/' + app.config['EXTERNAL_MAP_PATH'] +
                       graph_svg,
                   proposal_level_type=proposal_level_type,
                   user_level_type=user_level_type), 200


@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/voting_data',
           methods=['GET'])
@requires_auth
def api_get_voting_data(question_id):
    '''
    .. http:post:: questions/(int:question_id)/voting_data

        A map of voting results for a question.

        **Example request**:

        .. sourcecode:: http

            GET questions/42/voting_data HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

        :param question_id: question id
        :type question_id: int
        :param generation: generation
        :type generation: int
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_question_results called with %s...\n",
                     question_id)

    user = get_authenticated_user(request)
    if user is None:
        return jsonify(message = "User not logged in"), 404

    if question_id is None:
        return jsonify({"message": "Parameter question_id not set"}), 404

    question = models.Question.query.get(int(question_id))

    if question is None:
        return jsonify({"message": "Question not found"}), 401
        
    perm = question.get_permissions(user)
    if not perm:
        app.logger.debug("ACCESS ERROR: User %s with permission %s tried to vote on question %s", user.id, perm, question.id)
        return jsonify(message = app.config['QUESTION_PERMISSION_DENIED_MESSAGE']), 400
    
    generation = int(request.args.get('generation', question.generation))

    voting_data = question.get_endorsement_results(generation)

    # app.logger.debug("results ==> %s", results)

    return jsonify(
        question_id=question.id,
        current_generation=question.generation,
        requested_generation=generation,
        num_items=len(voting_data),
        voting_data=voting_data), 200

@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/voting_map',
           methods=['GET'])
@requires_auth
def api_question_voting_map(question_id):
    '''
    .. http:get:: questions/(int:question_id)/voting_map

        Return a map of proposal dominations.

        **Example request**:

        .. sourcecode:: http

            GET questions/42/voting_map HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json


        :param question_id: question id
        :type question_id: int
        :param generation: generation
        :type generation: int
        :param algorithm: algorithm id
        :type algorithm: int
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_question_voting_map called with %s...\n",
                     question_id)
    
    user = get_authenticated_user(request)
    if user is None:
        return jsonify(message = "User not logged in"), 404

    if question_id is None:
        
        return jsonify({"message": "Parameter question_id not set"}), 404

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        return jsonify({"message": "Question not found"}), 401
    
    # Check if user has permission to view the question
    perm = question.get_permissions(user)
    if not perm:
        app.logger.debug("ACCESS ERROR: User %s tried to access question %s", user.id, question.id)
        return jsonify(message = "You do not have permission to view this question"), 404

    generation = int(request.args.get('generation', question.generation))

    voting_map = question.voting_map()

    # app.logger.debug("voting_map=====>%s", voting_map)

    return jsonify(
        question_id=str(question.id),
        current_generation=str(question.generation),
        num_items=str(len(voting_map)),
        voting_map=voting_map), 200

@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/levels_map',
           methods=['GET'])
@requires_auth
def api_question_levels_map(question_id=None):
    '''
    .. http:get:: questions/(int:question_id)/levels_map

        A map of proposal dominations.

        **Example request**:

        .. sourcecode:: http

            GET questions/42/levels_map HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json


        :param question_id: question id
        :type question_id: int
        :param generation: generation
        :type generation: int
        :param algorithm: algorithm id
        :type algorithm: int
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_question_levels_map called with %s...\n",
                     question_id)
    
    # Check user is logged in
    user = get_authenticated_user(request)
    if user is None:
        return jsonify(message = "User not logged in"), 404

    if question_id is None:
        return jsonify({"message": "Parameter question_id not set"}), 404

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        return jsonify({"message": "Question not found"}), 401
    
    # Check if user has permission to view the question
    perm = question.get_permissions(user)
    if not perm:
        app.logger.debug("ACCESS ERROR: User %s tried to access question %s", user.id, question.id)
        return jsonify(message = "You do not have permission to view this question"), 404

    generation = int(request.args.get('generation', question.generation))
    # set Algorithm version
    algorithm = int(request.args.get('algorithm', app.config['ALGORITHM_VERSION']))

    levels =\
        question.calculate_levels_map(generation=generation, algorithm=algorithm)
    app.logger.debug("levels=====>%s", levels)

    levels_map = []
    for (proposal_id, levels) in levels.iteritems():
        levels_map.append({"id": proposal_id, "levels": levels})

    return jsonify(
        question_id=str(question.id),
        query_generation=str(generation),
        current_generation=str(question.generation),
        num_items=str(len(levels_map)),
        levels_map=levels_map), 200

@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/domination_map',
           methods=['GET'])
@requires_auth
def api_question_domination_map(question_id=None):
    '''
    .. http:get:: questions/(int:question_id)/domination_map

        Return a map of proposal dominations.

        **Example request**:

        .. sourcecode:: http

            GET questions/42/domination_map HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json


        :param question_id: question id
        :type question_id: int
        :param generation: generation
        :type generation: int
        :param algorithm: algorithm id
        :type algorithm: int
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_question_domination_map called with %s...\n",
                     question_id)

    # Check user is logged in
    user = get_authenticated_user(request)
    if user is None:
        return jsonify(message = "User not logged in"), 404
    
    if question_id is None:
        return jsonify({"message": "Parameter question_id not set"}), 404

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        return jsonify({"message": "Question not found"}), 401
    
    # Check if user has permission to view the question
    perm = question.get_permissions(user)
    if not perm:
        app.logger.debug("ACCESS ERROR: User %s tried to access question %s", user.id, question.id)
        return jsonify(message = "You do not have permission to view this question"), 404

    generation = int(request.args.get('generation', question.generation))
    # set Algorithm version
    algorithm = int(request.args.get('algorithm', app.config['ALGORITHM_VERSION']))

    # domination_map =\
    #     question.calculate_domination_map(generation=generation, algorithm=algorithm)

    relations =\
        question.calculate_domination_map(generation=generation, algorithm=algorithm)
    keys = relations.keys()
    app.logger.debug("Domination Map: keys ==> %s", keys)

    app.logger.debug("Domination Map: relations ==> %s", relations)

    domination_map = []

    for (proposal_id, dominations) in relations.iteritems():

        '''
        app.logger.debug("Processing relations for proposal %s", proposal.id)
        app.logger.debug("%s Dominated ==>%s", proposal.id, relations['dominated'])
        app.logger.debug("%s Dominating ==>%s", proposal.id, relations['dominating'])
        '''
        '''
        doms = []
        for (pid, relation) in dominations.iteritems():
            doms.append({"pid": pid, "relation": relation})
        '''
        
        # app.logger.debug("dominations===>>>>> %s", dominations)

        app.logger.debug("Dom Table Symbols: %s", DOMINATION_MAP_SYMBOLS)
        domination_list = []
        for pid in keys:
            domination_list.append( DOMINATION_MAP_SYMBOLS[ dominations[pid] ] )
        domination_map.append({"id": int(proposal_id), "dominations": domination_list})

        # app.logger.debug("domination_map==>%s", domination_map)

    return jsonify(
        question_id=str(question.id),
        query_generation=str(generation),
        current_generation=str(question.generation),
        num_items=str(len(domination_map)),
        domination_map=domination_map), 200

@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/proposal_relations',
           methods=['GET'])
@requires_auth
def api_question_proposal_relations(question_id=None):
    '''
    .. http:post:: questions/(int:question_id)/proposal_relations

        A list of proposal relations.

        **Example request**:

        .. sourcecode:: http

            GET questions/42/proposal_relations HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
              "query_generation": "1",
              "current_generation": "1",
              "objects": [
                {
                  "3": {
                    "dominating": [
                      {
                        "question_url": "/api/v1/questions/1",
                        "author_url": "/api/v1/users/3",
                        "title": "Bills First Proposal",
                        "url": "/api/v1/questions/1/proposals/1",
                        "abstract": null,
                        "created": "2013-08-13 10:42:55.625328",
                        "id": "1",
                        "blurb": "Bills blurb of varying interest",
                        "generation_created": "1"
                      }
                    ],
                    "dominated": []
                  }
                },
                {
                  "2": {
                    "dominating": [],
                    "dominated": []
                  }
                },
                {
                  "1": {
                    "dominating": [],
                    "dominated": [
                      {
                        "question_url": "/api/v1/questions/1",
                        "author_url": "/api/v1/users/2",
                        "title": "Susans Only Proposal",
                        "url": "/api/v1/questions/1/proposals/3",
                        "abstract": "Blah blah blah",
                        "created": "2013-08-13 10:42:55.664450",
                        "id": "3",
                        "blurb": "My blub is cool",
                        "generation_created": "1"
                      }
                    ]
                  }
                },
                {
                  "4": {
                    "dominating": [],
                    "dominated": []
                  }
                }
              ],
              "num_items": "4",
              "question_id": "1"
            }

        :param question_id: question id
        :type question_id: int
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_question_proposal_relations called with %s...\n",
                     question_id)

    # Check user is logged in
    user = get_authenticated_user(request)
    if user is None:
        return jsonify(message = "User not logged in"), 404
    
    if question_id is None:
        return jsonify({"message": "Parameter question_id not set"}), 404

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        return jsonify({"message": "Question not found"}), 401
    
    # Check if user has permission to view the question
    perm = question.get_permissions(user)
    if not perm:
        app.logger.debug("ACCESS ERROR: User %s tried to access question %s", user.id, question.id)
        return jsonify(message = "You do not have permission to view this question"), 404

    generation = int(request.args.get('generation', question.generation))
    proposal_relations =\
        question.calculate_proposal_relations(generation=generation)

    app.logger.debug("Proposal Relations==> %s", proposal_relations)

    results = []
    for (proposal, relations) in proposal_relations.iteritems():
        dominated_public = replaceWithPublic(relations['dominated'])
        dominating_public = replaceWithPublic(relations['dominating'])

        prop_relations = {
            'dominated': dominated_public,
            'dominating': dominating_public}

        results.append({proposal.id: prop_relations})

    return jsonify(
        question_id=str(question.id),
        query_generation=str(generation),
        current_generation=str(question.generation),
        num_items=str(len(proposal_relations)), proposal_relations=results), 200


# Get New Invitations
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/new_invites',
           methods=['GET'])
@requires_auth
def api_get_new_invites(question_id):
    '''
    .. http:get:: /questions/(int:question_id)/new_invites

        A list of new invitations for a question whih have not yet ben accepted or declined.

        **Example request**:

        .. sourcecode:: http

            GET /questions/45/new_invites HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
              "total_items": "4",
              "items": "2",
              "objects": [
                {
                  "receiver_id": "/api/v1/users/2",
                  "sender_url": "/api/v1/users/1",
                  "sender_id": 1,
                  "id": "1",
                  "question_id": 1
                },
                {
                  "receiver_id": "/api/v1/users/3",
                  "sender_url": "/api/v1/users/1",
                  "sender_id": 1,
                  "id": "2",
                  "question_id": 1
                }
              ],
              "page": "1",
              "pages": "2"
            }

        :param question_id: question ID
        :type question_id: int
        :query page: results page number, default is 1
        :statuscode 200: no error
        :statuscode 404: bad request
    '''
    app.logger.debug("api_get_new_invites called...\n")

    # Check user is logged in
    user = get_authenticated_user(request)
    if user is None:
        return jsonify(message = "User not logged in"), 404
    
    if question_id is None:
        return jsonify({"message": "Parameter question_id not set"}), 404

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        return jsonify({"message": "Question not found"}), 401
    
    # Check if user has permission to view the question
    perm = question.get_permissions(user)
    if not perm:
        app.logger.debug("ACCESS ERROR: User %s tried to access question %s", user.id, question.id)
        return jsonify(message = "You do not have permission to view this question"), 404

    page = int(request.args.get('page', 1))

    invites = models.UserInvite.query.filter(
        models.UserInvite.question_id == int(question_id)).\
        paginate(page, RESULTS_PER_PAGE, False)

    items = len(invites.items)
    pages = invites.pages
    total_items = invites.total

    results = []
    for i in invites.items:
        results.append(i.get_public())

    return jsonify(total_items=str(total_items), items=str(items),
                   page=str(page), pages=str(pages),
                   invitations=results), 200

# Get Invitations
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/invitations',
           methods=['GET'])
@requires_auth
def api_get_invitations(question_id):
    '''
    .. http:get:: /questions/(int:question_id)/invitations

        A list of invitations for a question.

        **Example request**:

        .. sourcecode:: http

            GET /questions/45/invitations HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
              "total_items": "4",
              "items": "2",
              "objects": [
                {
                  "receiver_id": "/api/v1/users/2",
                  "sender_url": "/api/v1/users/1",
                  "sender_id": 1,
                  "id": "1",
                  "question_id": 1
                },
                {
                  "receiver_id": "/api/v1/users/3",
                  "sender_url": "/api/v1/users/1",
                  "sender_id": 1,
                  "id": "2",
                  "question_id": 1
                }
              ],
              "page": "1",
              "pages": "2"
            }

        :param question_id: question ID
        :type question_id: int
        :query page: results page number, default is 1
        :statuscode 200: no error
        :statuscode 404: bad request
    '''
    app.logger.debug("api_get_invitations called...\n")

    # Check user is logged in
    user = get_authenticated_user(request)
    if user is None:
        return jsonify(message = "User not logged in"), 404
    
    if question_id is None:
        return jsonify({"message": "Parameter question_id not set"}), 404

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        return jsonify({"message": "Question not found"}), 401
    
    # Check if user has permission to view the question
    perm = question.get_permissions(user)
    if not perm:
        app.logger.debug("ACCESS ERROR: User %s tried to access question %s", user.id, question.id)
        return jsonify(message = "You do not have permission to view this question"), 404

    page = int(request.args.get('page', 1))

    invites = models.Invite.query.filter(
        models.Invite.question_id == int(question_id)).\
        paginate(page, RESULTS_PER_PAGE, False)

    items = len(invites.items)
    pages = invites.pages
    total_items = invites.total

    results = []
    for i in invites.items:
        results.append(i.get_public())

    return jsonify(total_items=str(total_items), items=str(items),
                   page=str(page), pages=str(pages),
                   invitations=results), 200


# Create Email Invitation
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/emailinvitations',
           methods=['POST'])
@requires_auth
def api_create_email_invitation(question_id):
    '''
    .. http:post:: questions/(int:question_id)/emailinvitations

        Create invitations to a question.

        **Example request**:

        .. sourcecode:: http

            POST questions/45/invitations HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
              "message": "Invites sent"
            }

        :param question_id: question id
        :type question_id: int
        :json invite_user_ids: list of user ids to invite
        :statuscode 201: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_create_email_invitation called...\n")

    # Check user is logged in
    user = get_authenticated_user(request)
    if user is None:
        return jsonify(message = "User not logged in"), 404
    
    if question_id is None:
        return jsonify({"message": "Parameter question_id not set"}), 404

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        return jsonify({"message": "Question not found"}), 401
    
    # Check if user has permission to view the question
    perm = question.get_permissions(user)
    if not perm:
        app.logger.debug("ACCESS ERROR: User %s tried to access question %s", user.id, question.id)
        return jsonify(message = "You do not have permission to view this question"), 404

    if not request.json:
        return jsonify({"message": "JSON object not set in request"}), 400

    if not 'user_emails' in request.json:
        return jsonify({"message": "Parameter user_emails not set"}), 404

    permissions = int(request.json.get('permissions', models.Question.READ))
    user_emails = request.json['user_emails']
    email_list = user_emails.split(',')

    rejected = list()
    accepted = list()
    already_sent = list()
    invites_count = 0

    for email in email_list:
        email = email.strip()
        if not '@' in email:
            app.logger.debug("@ not found in %s", email)

            if email not in rejected:
                rejected.append(email)
            continue
        else:
            instance = db_session.query(models.EmailInvite)\
                .filter(and_(models.EmailInvite.receiver_email == email,
                             models.EmailInvite.sender_id == user.id,
                             models.EmailInvite.question_id == question.id))\
                .first()
            if instance:
                app.logger.debug("Address %s already contacted", email)
                if email not in already_sent:
                    already_sent.append(email)
                continue
            else:
                accepted.append(email)
                token = uuid.uuid4().get_hex()
                new_invite = models.EmailInvite(user, email, permissions, question_id, token)

                # send email aesynchronously - (Check sent)
                emails.send_question_email_invite_email(user, email, question, token)
                new_invite.email_sent = 1

                db_session.add(new_invite)
                invites_count = invites_count + 1
                # Send email
                # email_question_email_invite(user, email, question)

    if invites_count:
        db_session.commit()

    addresses_already_sent = ",".join(already_sent)
    rejected_addresses = ",".join(rejected)
    accepted_addresses = ",".join(accepted)
    invites = {'question_id': str(question_id),
                'accepted': accepted_addresses,
                'rejected': rejected_addresses,
                'already_sent': addresses_already_sent,
                'num_invites_sent': str(invites_count)}

    return jsonify(invites=invites), 201


# Create Invitation
@app.route(REST_URL_PREFIX + '/questions/<int:question_id>/invitations',
           methods=['POST'])
@requires_auth
def api_create_invitation(question_id):
    '''
    .. http:post:: questions/(int:question_id)/invitations

        Create invitations to a question.

        **Example request**:

        .. sourcecode:: http

            POST questions/45/invitations HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
              "message": "Invites sent"
            }

        :param question_id: question id
        :type question_id: int
        :json invite_user_ids: list of user ids to invite
        :statuscode 201: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_create_invitation called...\n")

    # Check user is logged in
    user = get_authenticated_user(request)
    if user is None:
        return jsonify(message = "User not logged in"), 404
    
    if question_id is None:
        return jsonify({"message": "Parameter question_id not set"}), 404

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        return jsonify({"message": "Question not found"}), 401
    
    # Check if user has permission to view the question
    perm = question.get_permissions(user)
    if not perm:
        app.logger.debug("ACCESS ERROR: User %s tried to access question %s", user.id, question.id)
        return jsonify(message = "You do not have permission to view this question"), 404

    if not request.json:
        return jsonify({"message": "JSON object not set in request"}), 400

    if not 'invite_user_ids' in request.json:
        return jsonify(message = "Parameter invite_user_ids not set"), 400

    invite_user_ids = request.json['invite_user_ids']

    permissions = int(request.json.get('permissions', models.Question.READ))

    for id in invite_user_ids:
        try:
            id = int(id)
        except ValueError:
            app.logger.debug(
                "Param invite_user_ids contains non integer values!\n")
            abort(400)

    app.logger.debug("invite_user_ids = %s\n", invite_user_ids)

    app.logger.debug("calling invite_all with users %s\n", invite_user_ids)
    if user.invite_all(invite_user_ids, permissions, question):
        app.logger.debug("invites created\n")
        db_session.commit()
        return jsonify(message="Invites created"), 201
    else:
        return jsonify(message="Unable to create invites"), 500


# Get subscriptions
#
@app.route(REST_URL_PREFIX + '/users/<int:user_id>/subscriptions', methods=['GET'])
@app.route(REST_URL_PREFIX + '/users/<int:user_id>/subscriptions/<int:question_id>',
           methods=['GET'])
@requires_auth
def api_get_user_subscriptions(user_id, question_id=None):
    '''
    .. http:get:: users/(int:user_id)/subscriptions

        A subscription or list of subscriptions to a question.

        **Example request**:

        .. sourcecode:: http

            GET users/12/subscriptions HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "total_items": 3,
              "items": 2,
              "objects": [
                {
                  "url": "/users/1/subscriptions/1",
                  "how": "asap",
                  "last_update": "None",
                  "question_id": "1"
                },
                {
                  "url": "/users/1/subscriptions/2",
                  "how": "asap",
                  "last_update": "None",
                  "question_id": "2"
                }
              ],
              "page": "1",
              "pages": "2"
            }

        :param user_id: user id
        :type user_id: int
        :param question_id: question id
        :type question_id: int
        :query page: page number, defaults to 1
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_get_user_subscriptions called...\n")
    
    # Check user is logged in
    user = get_authenticated_user(request)
    if user is None:
        return jsonify(message = "User not logged in"), 404

    if user_id is None:
        return jsonify({"message": "Parameter user_id not set"}), 404
        
    if user_id != user.id:
        return jsonify({"message": "User can only view his own subscriotions"}), 404

    if question_id is not None:
        question = models.Question.query.get(int(question_id))
        if question is None:
            return jsonify({"message": "Question not found"}), 401

        subscribed_question = user.subscribed_questions.\
            filter(models.Update.question_id == int(question_id)).one()

        if subscribed_question is None:
            return jsonify({"message": "Question subscription not found"}), 401

        app.logger.debug("Subscribed question ID %s\n",
                         subscribed_question.question_id)
        '''
        subscriptions = [{'question_id': subscribed_question.question_id,
                          'how': subscribed_question.how,
                          'last_update': str(subscribed_question.last_update)}]
        '''
        results = [subscribed_question.get_public()]
        return jsonify(object=results), 200

    else:
        page = int(request.args.get('page', 1))
        subscribed_questions = user.subscribed_questions.\
            paginate(page, RESULTS_PER_PAGE, False)
        items = len(subscribed_questions.items)
        pages = subscribed_questions.pages
        total_items = subscribed_questions.total

        results = []
        for s in subscribed_questions.items:
            results.append(s.get_public())

        return jsonify(total_items=total_items, items=(items),
                       page=str(page), pages=str(pages),
                       subscriptions=results), 200


#
# Create Subscription
#
@app.route(REST_URL_PREFIX + '/users/<int:user_id>/subscriptions', methods=['POST'])
@requires_auth
def api_add_user_subscriptions(user_id):
    '''
    .. http:post:: /users/(int:user_id)/subscriptions

        Create a subscription.

        **Example request**:

        .. sourcecode:: http

            POST /users/22/subscriptions HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
              "url": "/api/v1/users/1/subscriptions/1"
            }

        :param user_id: user id
        :type user_id: int
        :json question_id: question id
        :json how: one of daily, weekly, or asap
        :statuscode 201: no error
        :statuscode 400: bad request
        :statuscode 401: unauthorized
    '''
    app.logger.debug("api_add_user_subscriptions called...\n")

    # Check user is logged in
    user = get_authenticated_user(request)
    if user is None:
        return jsonify(message = "User not logged in"), 404

    if not request.json:
        message = 'No json object found'
        return jsonify(message=message), 400

    if not 'how' in request.json\
            or not request.json['how'] in ['daily', 'weekly', 'asap']:
        message = 'Parameter how not set'
        return jsonify(message=message), 400

    if not 'question_id' in request.json:
        message = 'Parameter question_id not set'
        return jsonify(message=message), 400

    question_id = int(request.json['question_id'])
    question = models.Question.query.get(int(question_id))
    if question is None:
        return jsonify({"message": "Question not found"}), 401

    how = request.json['how']

    if user.subscribed_questions.filter(
            models.Update.question_id == question_id).count() == 1:
        message = 'User already subscribed'
        return jsonify(message=message), 400

    user.subscribe_to(question, how)
    db_session.add(user)
    db_session.commit()

    return jsonify({'url': url_for('api_get_user_subscriptions',
                                   user_id=user_id,
                                   question_id=question_id)}), 201


#
# Update subscription
#
@app.route(REST_URL_PREFIX + '/users/<int:user_id>/subscriptions',
           methods=['POST'])
@requires_auth
def api_update_user_subscriptions(user_id):
    '''
    .. http:post:: /users/(int:user_id)/subscriptions

        Update a user's question subscription'.

        **Example request**:

        .. sourcecode:: http

            POST users/56/subscriptions HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
              "objects": [
                {
                  "how": "asap",
                  "last_update": "None",
                  "question_id": 3
                }
              ]
            }

        :param user_id: user id
        :type user_id: int
        :json question_id: question id
        :json how: one of daily, weekly, or asap
        :statuscode 201: no error
        :statuscode 400: bad request
        :statuscode 401: unauthorized
    '''
    app.logger.debug("api_update_user_subscriptions called...\n")

    # Check user is logged in
    user = get_authenticated_user(request)
    if user is None:
        return jsonify(message = "User not logged in"), 404

    if not request.json:
        return jsonify({"message": "JSON object not set in request"}), 400

    if user_id is None:
        return jsonify(message = "Parameter user_id not set"), 400

    if user.id != user_id:
        return jsonify(message = "Only user can update his subscriptions"), 400

    if not 'question_id' in request.json:
        msg_txt = "You must supply the parameter 'question_id' " +\
                  "set to the id of the question" +\
                  "you wish to subscribe to"
        message = {"message": msg_txt}
        return jsonify(message), 400

    question_id = int(request.json['question_id'])
    question = models.Question.query.get(int(question_id))
    if question is None:
        return jsonify({"message": "Question not found"}), 401

    if not 'how' in request.json \
            or not request.json['how'] in ['daily', 'weekly', 'asap']:
        msg_txt = "You must supply the parameter 'how' " +\
                  "set to one of the desired" +\
                  "update methods: 'daily', 'weekly', 'asap'"
        message = {"message": msg_txt}
        return jsonify(message), 400

    subscription = user.subscribed_questions.\
        filter(models.Update.question_id == int(question_id)).first()

    if subscription is None:
        abort(404)

    subscription.how = request.json['how']
    # db_session.add(user)
    db_session.commit()

    subscription = [{'question_id': subscription.question_id,
                    'how': subscription.how,
                    'last_update': str(subscription.last_update)}]

    return jsonify(objects=subscription), 201


# Delete subscription
#
# @app.route(REST_URL_PREFIX + '/subscriptions/<int:question_id>',
@app.route(REST_URL_PREFIX + '/users/<int:user_id>/subscriptions/<int:question_id>',
           methods=['DELETE'])
@requires_auth
def api_delete_user_subscriptions(user_id, question_id):
    '''
    .. http:delete:: /users/(int:user_id)/subscriptions/(int:question_id)

        Delete a question subscription.

        **Example request**:

        .. sourcecode:: http

            DELETE users/56/subscriptions/44 HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
            "message": "Subscription Deleted"
            }

        :param user_id: user id
        :type user_id: int
        :param question_id: question id
        :type question_id: int
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_delete_user_subscriptions called...\n")

    # Check user is logged in
    user = get_authenticated_user(request)
    if user is None:
        return jsonify(message = "User not logged in"), 404

    if not request.json:
        return jsonify({"message": "JSON object not set in request"}), 400

    if user_id is None:
        return jsonify(message = "Parameter user_id not set"), 400

    if user.id != user_id:
        return jsonify(message = "Only user can update his subscriptions"), 400
    
    if not 'question_id' in request.json:
        msg_txt = "You must supply the parameter 'question_id' " +\
                  "set to the id of the question" +\
                  "you wish to subscribe to"
        message = {"message": msg_txt}
        return jsonify(message), 400

    question_id = int(request.json['question_id'])
    question = models.Question.query.get(int(question_id))
    if question is None:
        return jsonify({"message": "Question not found"}), 401

    subscription = user.subscribed_questions.filter(and_(
        models.Update.question_id == int(question_id),
        models.Update.user_id == user.id)).first()

    if subscription is not None:
        user.subscribed_questions.remove(subscription)
    db_session.add(user)
    db_session.commit()
    return jsonify(message="Subscription deleted"), 200
