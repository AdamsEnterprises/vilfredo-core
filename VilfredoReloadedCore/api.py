#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of VilfredoReloadedCore.
#
# Copyright Â© 2009-2013 Pietro Speroni di Fenizio / Derek Paterson.
#
# VilfredoReloadedCore is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation version 3 of the License.
#
# VilfredoReloadedCore is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with VilfredoReloadedCore.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################


'''
REST API
========

'''

from flask import request,\
    url_for, jsonify, make_response, abort
from . import app, models
from .auth import login_manager, login_serializer
from .database import db_session
from sqlalchemy import and_
from functools import wraps
from flask import Response
import json


REST_API_VERSION = 'v1'
REST_URL_PREFIX = '/api/' + REST_API_VERSION
RESULTS_PER_PAGE = 50

MAX_LEN_EMAIL = 120
MAX_LEN_USERNAME = 20
MAX_LEN_PASSWORD = 120
MIN_LEN_PASSWORD = 6
MAX_LEN_ROOM = 20
MIN_LEN_ROOM = 2
MAX_LEN_PROPOSAL_TITLE = 100
MAX_LEN_PROPOSAL_ABSTRACT = 1000
MAX_LEN_PROPOSAL_BLURB = 1000
MAX_LEN_QUESTION_TITLE = 100
MAX_LEN_QUESTION_BLURB = 2000
MAX_LEN_PROPOSAL_COMMENT = 300
MAX_LEN_PROPOSAL_QUESTION = 300
MAX_LEN_PROPOSAL_QUESTION_ANSWER = 300
ENDORSEMENT_TYPES = ['endorse', 'oppose', 'confused']
COMMENT_TYPES = ['for', 'against', 'question', 'answer']
PWD_RESET_LIFETIME = 3600*24*2

# &hellip; ....
# &NotGreaterLess;

DOMINATION_MAP_SYMBOLS = {-2: '&approx;', -1: '&equiv;', 0: '&hellip;', 1: '^', 2: '<', 3: '&uHar;', 4: '&lHar;', 5: '<span class="partial2full">&uHar;</span>', 6: '<span class="partial2full">&lHar;</span>'}

'''
from flask_login import LoginManager
login_manager = LoginManager()
login_manager.init_app(app)
# Login_serializer used to encryt and decrypt the cookie token for the remember
# me option of flask-login
from itsdangerous import URLSafeTimedSerializer
try:
    login_serializer = URLSafeTimedSerializer(app.config['SECRET_KEY'], app.config['SALT'])
except Exception:
    print 'Failed to create login_serializer'
'''

@login_manager.token_loader
def load_token(token):
    """
    Flask-Login token_loader callback.
    The token_loader function asks this function to take the token that was
    stored on the users computer process it to check if its valid and then
    return a User Object if its valid or None if its not valid.
    """

    app.logger.debug("load_token called...")
 
    #The Token itself was generated by User.get_auth_token.  So it is up to
    #us to known the format of the token data itself.  
 
    #The Token was encrypted using itsdangerous.URLSafeTimedSerializer which
    #allows us to have a max_age on the token itself.  When the cookie is stored
    #on the users computer it also has a exipry date, but could be changed by
    #the user, so this feature allows us to enforce the exipry date of the token
    #server side and not rely on the users cookie to exipre.
    max_age = app.config["REMEMBER_COOKIE_DURATION"].total_seconds()
 
    #Decrypt the Security Token, data = [username, hashpass]
    #from . import login_serializer
    
    try:
        data = login_serializer.loads(token, max_age=max_age)
    except:
        app.logger.debug('load_token raised error')
        return None
 
    #Find the User
    user = models.User.get(int(data[0]))
 
    #Check Password and return user or None
    if user and data[1] == user.password:
        return user
    return None

def authenticate():
    """Sends a 403 response that enables basic auth"""
    return Response(
        'You have to login to make this request', 403,
        {'WWW-Authenticate': 'Basic realm="Login Required"'})


def requires_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        app.logger.debug("Request authorization = %s\n", request.authorization)
        auth = request.authorization
        if not auth:
            #return authenticate()
            return jsonify(message='auth not defined'), 403
        if auth.username == '':
            #return authenticate()
            return jsonify(message='no username received'), 403
        if auth.password == '':
            app.logger.debug('requires_auth: Token set')
            token_valid = load_token(auth.username)
            if token_valid:
                app.logger.debug('requires_auth: Token is valid')
                return f(*args, **kwargs)
            else:
                app.logger.debug('requires_auth: Token is not valid')
                # return authenticate()
                return jsonify(message='no password received, incorrect token supplied'), 403
        elif check_auth(auth.username, auth.password):
            app.logger.debug('requires_auth: username and password valid')
            return f(*args, **kwargs)
        else:
            app.logger.debug('requires_auth: username and password not valid')
            # return authenticate()
            return jsonify(message='username and password not valid'), 403
    return decorated

def requires_auth_off(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        auth = request.authorization
        app.logger.debug("Request authorization = %s\n", request.authorization)
        if not auth:
            return authenticate()
        if auth.username == '':
            return authenticate()
        if auth.password == '':
            app.logger.debug('requires_auth: Token set')
            token_valid = load_token(auth.username)
            if token_valid:
                app.logger.debug('requires_auth: Token is valid')
                return f(*args, **kwargs)
            else:
                app.logger.debug('requires_auth: Token is not valid')
                return authenticate()
        elif check_auth(auth.username, auth.password):
            app.logger.debug('requires_auth: username and password valid')
            return f(*args, **kwargs)
        else:
            app.logger.debug('requires_auth: username and password not valid')
            return authenticate()
    return decorated

def requires_auth_V1(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        auth = request.authorization
        app.logger.debug("Request authorization = %s\n", request.authorization)
        if not auth or not check_auth(auth.username, auth.password):
            return authenticate()
        return f(*args, **kwargs)
    return decorated


def check_auth(username, password):
    '''
    .. function:: check_auth(username, password)

    Authenticates user.

    :param username: user name.
    :type username: String
    :param password: user name.
    :type password: String
    :rtype: Boolean
    '''
    user = None
    if username == '' or password == '':
        return False
    try:
        user = models.User.query.filter_by(username=username).one()
    except:
        pass
    if user is None:
        return False
    else:
        return user.check_password(password)


def get_authenticated_user(request):
    '''
    .. function:: get_authenticated_user(request)

    Returns the authenticated user.

    :param request: HTTP request.
    :type request: Object
    :rtype: User or None
    '''
    app.logger.debug("get_authenticated_user called....")
    app.logger.debug("auth into ==> %s", request.authorization)
    if request.authorization:
        if request.authorization.password == '':
            user = load_token(request.authorization.username)
        else:
            user = models.User.query.\
                filter_by(username=request.authorization.username).one()
        return user
    else:
        app.logger.debug("get_authenticated_user: no authorization found")
        return None

def get_authenticated_user_with_token_1(request):
    '''
    .. function:: get_authenticated_user(request)

    Returns the authenticated user.

    :param request: HTTP request.
    :type request: Object
    :rtype: User or None
    '''
    app.logger.debug("get_authenticated_user called....")
    app.logger.debug("auth into ==> %s", request.authorization)
    if request.authorization:
        user = load_token(request.authorization.username)
        if not user:
            user = models.User.query.\
                filter_by(username=request.authorization.username).one()
        return user
    else:
        app.logger.debug("get_authenticated_user: no authorization found")
        return None

def get_authenticated_user_OFF(request):
    '''
    .. function:: get_authenticated_user(request)

    Returns the authenticated user.

    :param request: HTTP request.
    :type request: Object
    :rtype: User or None
    '''
    app.logger.debug("get_authenticated_user called....")
    app.logger.debug("auth into ==> %s", request.authorization)
    if request.authorization:
        if 'token' in request.authorization and request.authorization.token != '':
            app.logger.debug('token found!!!! Try to load...');
            return load_token(request.authorization.token)
        elif 'username' in request.authorization and 'password' in request.authorization\
                and request.authorization.username != '' and request.authorization.password != '':
            return models.User.query.\
                filter_by(username=request.authorization.username).one()
        else:
            app.logger.debug("get_authenticated_user: authorization invalid")
            return None
    else:
        app.logger.debug("get_authenticated_user: no authorization found")
        return None

def get_authenticated_user_current(request):
    '''
    .. function:: get_authenticated_user(request)

    Returns the authenticated user.

    :param request: HTTP request.
    :type request: Object
    :rtype: User or None
    '''
    if 'request.json' in locals() or 'request.json' in globals() and 'token' in request.json:
        app.logger.debug("get_authenticated_user: token found")
        return load_token(request.json['token'])
    elif request.authorization and request.authorization.username != '' and request.authorization.password != '':
        app.logger.debug("get_authenticated_user: authorization found: %s", request.authorization)

        if 'authtoken' in request.authorization:
            return load_token(request.authorization.authtoken)
        else:
            return models.User.query.\
                filter_by(username=request.authorization.username).one()
    else:
        app.logger.debug("get_authenticated_user: no authorization found")
        return None

def get_authenticated_user_v1(request):
    '''
    .. function:: get_authenticated_user(request)

    Returns the authenticated user.

    :param request: HTTP request.
    :type request: Object
    :rtype: User or None
    '''
    if 'request.json' in locals() or 'request.json' in globals() and 'token' in request.json:
        app.logger.debug("get_authenticated_user: token found")
        return load_token(request.json['token'])
    elif request.authorization:
        app.logger.debug("get_authenticated_user: authorization found")
        return models.User.query.\
            filter_by(username=request.authorization.username).one()
    else:
        app.logger.debug("get_authenticated_user: no authorization found")
        return None


@app.errorhandler(404)
def not_found(error):
    return make_response(jsonify({'error': 'Not found'}), 404)


@app.errorhandler(400)
def bad_request(error):
    return make_response(jsonify({'error': 'Bad request'}), 400)


#
# Index
#
@app.route('/api/v1/', methods=['GET', 'POST'])
@app.route('/api/v1/index', methods=['GET', 'POST'])
def api_index():
    app.logger.debug("api_index called...\n")

    # Get authenticated user or None
    current_user = get_authenticated_user(request)

    if current_user:
        message = "Welcome back " + current_user.username +\
            " to the Vilfredo REST API"
    else:
        message = "Welcome to the the Vilfredo REST API"

    return jsonify(message=message), 200


#
# Get Auth Token
#
@app.route('/api/v1/authtoken', methods=['GET'])
@requires_auth
def api_get_auth_token():
    app.logger.debug("api_get_auth_token called...\n")
    user = get_authenticated_user(request)
    if not user:
        app.logger.debug("user not found...\n")
        abort(401)
    token = user.get_auth_token()
    app.logger.debug("token = %s\n", token)

    # Test for jsonp request
    if 'callback' in request.args:
        d = json.dumps(dict(token=token))
        return 'jsonCallback(' + d + ');', 200

    # Return raw json
    # response = {'token': token}
    # return jsonify(objects=response), 200
    return jsonify(token=token), 200

#
# Get Current User details
#
@app.route('/api/v1/currentuser', methods=['GET'])
@requires_auth
def api_get_current_user():
    app.logger.debug("api_get_current_user called...\n")
    user = get_authenticated_user(request)
    if not user:
        app.logger.debug("user not found...\n")
        abort(401)
    userdata = user.get_public()
    userdata['email'] = user.email
    return jsonify(user=userdata), 200


#
# Get Users
#
@app.route('/api/v1/users', methods=['GET'])
@app.route('/api/v1/users/<int:user_id>', methods=['GET'])
def api_get_users(user_id=None):
    '''
    .. http:get:: /users/(int:user_id)

        A user or list of users.

        **Example request**:

        .. sourcecode:: http

            GET /users/42 HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
               "total_items": 5,
               "items": "2",
               "objects":
               [
                   {
                       "username": "john",
                       "url": "/users/1",
                       "registered": "2013-08-12 09:51:38.559222",
                       "id": "1",
                       "last_seen": "2013-08-12 09:51:38.559240"
                   },
                   {
                       "username": "susan",
                       "url": "/users/2",
                       "registered": "2013-08-12 09:51:38.576731",
                       "id": "2",
                       "last_seen": "2013-08-12 09:51:38.576745"
                   }
               ],
               "page": "1",
               "pages": "2"
            }

        :param user_id: user id
        :type user_id: int
        :query page: page number. default is 1
        :statuscode 200: no error
        :statuscode 404: there's no user
    '''
    app.logger.debug("api_get_users called...\n")

    # Get authenticated user or None
    current_user = get_authenticated_user(request)

    if user_id is not None:
        user = models.User.query.get(int(user_id))
        if user is None:
            abort(404)

        results = user.get_public()

        if current_user and current_user.id == user.id:
            results['email'] = user.email

        return jsonify(user=results), 200

    else:
        page = int(request.args.get('page', 1))
        users = models.User.query.paginate(page,
                                           RESULTS_PER_PAGE,
                                           False)
        items = len(users.items)
        pages = users.pages
        total_items = users.total

        results = []
        for u in users.items:
            results.append(u.get_public())

        return jsonify(total_items=total_items, items=str(items),
                       page=str(page), pages=str(pages),
                       users=results), 200


# Update User Details
@app.route('/api/v1/users/<int:user_id>', methods=['PATCH'])
@requires_auth
def api_update_user(user_id):
    '''
    .. http:patch:: /users/(int:user_id)

        Update a user's details'.

        **Example request**:

        .. sourcecode:: http

            PATCH /users/42 HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
                "url": "/users/1"
            }

        :param user_id: user id
        :type user_id: int
        :json new_username: new username
        :json new_password: new password
        :json new_email: new email address
        :statuscode 200: no error
        :statuscode 404: there's no user
    '''
    if user_id is None:
        abort(404)

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    app.logger.debug("api_update_user called by %s...\n", user.id)

    if int(user_id) != user.id:
        response = {'message': 'You are not authorized to edit this resource'}
        return jsonify(objects=response), 401

    if not request.json:
        app.logger.debug("Non json request received...\n")
        abort(400)

    elif 'new_username' in request.json and \
            (request.json['new_username'] == '' or
             len(request.json['new_username']) > MAX_LEN_USERNAME):
        app.logger.debug("1...\n")
        abort(400)

    elif 'new_email' in request.json and \
            (request.json['new_email'] == '' or
             request.json['new_email'] > MAX_LEN_EMAIL):
        app.logger.debug("2...\n")
        abort(400)

    elif 'new_password' in request.json and \
            (len(request.json['new_password']) < MIN_LEN_PASSWORD or
             len(request.json['new_password']) > MAX_LEN_PASSWORD):
        app.logger.debug("3...\n")
        abort(400)

    elif models.User.username_available(request.json['new_username'])\
            is not True:
        message = "Username not available"
        # return jsonify(message=message), 400
        return jsonify("Username not available"), 400

    elif models.User.email_available(request.json['email']) is not True:
            response = {'message': 'Someone has already registered with that email.'}
            return jsonify(objects=response), 400

    user.username = request.json.get('new_username', user.username)
    user.email = request.json.get('new_email', user.email)

    if 'new_password' in request.json:
        user.set_password(request.json['new_password'])

    db_session.add(user)
    db_session.commit()
    response = {'url': url_for('api_get_users', user_id=user.id)}

    return jsonify(object=response), 201


#
# Password reset request
#
@app.route('/api/v1/request_password_reset', methods=['POST'])
def api_request_password_reset():
    app.logger.debug("api_request_password_reset called...\n")

    if not request.json:
        app.logger.debug("Non json request received...\n")
        message = "Non json request received"
        return jsonify(message=message), 400

    elif not 'email' in request.json or request.json['email'] == '' \
            or len(request.json['email']) > MAX_LEN_EMAIL:
        message = "A valid email is required"
        return jsonify(message=message), 400

    email = request.json['email']
    user = models.User.query.filter_by(email=email).one()
    if not user:
        message = "Email address not found"
        return jsonify(message=message), 400

    import uuid
    pwd_reset_token = uuid.uuid4().get_hex()
    timeout = models.get_timestamp() + PWD_RESET_LIFETIME
    pwd_reset = models.PWDReset(user, pwd_reset_token, timeout)
    db_session.add(pwd_reset)
    db_session.commit()
    # email reset token to user
    message = 'Password reset email sent'
    return jsonify(message=message), 201

#
# Password reset request
#
@app.route('/api/v1/submit_password_reset_token', methods=['GET'])
def api_submit_password_reset_token():
    app.logger.debug("api_request_password_reset called...\n")

    user_id = 0
    try:
        user_id = int(request.args.get('u'))
    except ValueError:
        app.logger.debug("No or invalid userid received...\n")
        message = "No or invalid userid received"
        return jsonify(message=message), 400

    pwd_reset_token = request.args.get('t', None)
    if not pwd_reset_token:
        app.logger.debug("No reset token received...\n")
        message = "No token received"
        return jsonify(message=message), 400

    pwd_reset = models.PWDReset.query.filter_by(token=pwd_reset_token, user_id=user_id).one()

    if not pwd_reset:
        app.logger.debug("Token and user_id not listed...\n")
        message = "Token and user_id not listed"
        return jsonify(message=message), 400

    elif models.get_timestamp() > pwd_reset.timeout:
        app.logger.debug("Token expired...\n")
        message = "Token expired"
        return jsonify(message=message), 400

    user = models.User.query.filter_by(id=user_id).one()
    auth_token = user.get_auth_token()
    app.logger.debug("token = %s\n", auth_token)
    return jsonify(token=token), 200

#
# Set new password and genberate new authentication token
#
@app.route('/api/v1/reset_password', methods=['POST'])
@requires_auth
def api_reset_password(token):
    app.logger.debug("api_reset_password called...\n")

    user = get_authenticated_user(request)
    if not user:
        response = {"message": "User not logged in"}
        return jsonify(response), 400

    app.logger.debug("Authenticated User = %s\n", user.id)

    if not 'password' in request.json or not 'password2' in request.json or \
            request.json['password'] != request.json['password2'] or \
            request.json['password'] == '' or \
            len(request.json['password']) < MIN_LEN_PASSWORD or \
            len(request.json['password']) > MAX_LEN_PASSWORD:
        message = "Passwords must match and must be between %s and %s characters" %\
            (MIN_LEN_PASSWORD, MAX_LEN_PASSWORD)
        return jsonify(message=message), 400

    # Delete reset token entry
    db_session.delete(pwd_reset)

    # Set new password
    user.set_password(request.json['password'])
    db_session.add(user)
    db_session.commit()

    # Generate new auth token
    token = user.get_auth_token()
    app.logger.debug("New token = %s\n", token)

    message = 'Password reset'
    return jsonify(message=message, token=token), 201


#
# Create User
#
@app.route('/api/v1/users', methods=['POST'])
def api_create_user():
    '''
    .. http:post:: /users

        Create a new user.

        **Example request**:

        .. sourcecode:: http

            POST /users HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
                "url": "/users/1"
            }

        :json username: username
        :json email: email address
        :json password: password
        :statuscode 201: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_create_user called...\n")

    app.logger.debug("Request %s...\n", request.json)

    if not request.json:
        app.logger.debug("Non json request received...\n")
        message = "Non json request received"
        return jsonify(message=message), 400

    elif not 'username' in request.json or request.json['username'] == '' \
            or len(request.json['username']) > MAX_LEN_USERNAME:
        message = "Username must be less than %s characters" % MAX_LEN_USERNAME
        return jsonify(message=message), 400

    elif not 'email' in request.json or request.json['email'] == '' \
            or len(request.json['email']) > MAX_LEN_EMAIL:
        message = "Email required and must be shorter than %s characters" %\
                  MAX_LEN_EMAIL
        return jsonify(message=message), 400

    elif not 'password' in request.json or request.json['password'] == '' or \
            len(request.json['password']) < MIN_LEN_PASSWORD or \
            len(request.json['password']) > MAX_LEN_PASSWORD:
        message = "Password must be between %s and %s characters" %\
            (MIN_LEN_PASSWORD, MAX_LEN_PASSWORD)
        return jsonify(message=message), 400

    elif models.User.username_available(request.json['username'])\
            is not True:
        message = "Username not available"
        return jsonify(message=message), 400
        # return jsonify("Username not available"), 400
        # return make_response(jsonify({'error': 'Username not available'}), 400)

    elif models.User.email_available(request.json['email']) is not True:
        message = "Someone has already registered with that email."
        return jsonify(message=message), 400

    user = models.User(request.json['username'],
                       request.json['email'],
                       request.json['password'])
    db_session.add(user)
    db_session.commit()
    response = {'url': url_for('api_get_users', user_id=user.id)}

    return jsonify(response), 201


#
# Get Questions
#
@app.route('/api/v1/questions', methods=['GET'])
@app.route('/api/v1/questions/<int:question_id>', methods=['GET'])
def api_get_questions(question_id=None):
    '''
    .. http:get:: /questions/(int:question_id)

        A question or list of questions.

        **Example request**:

        .. sourcecode:: http

            GET /questions/42 HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "total_items": "3",
              "items": "2",
              "objects": [
                {
                  "last_move_on": "2013-08-12 09:51:38.632780",
                  "created": "2013-08-12 09:51:38.632763",
                  "title": "My question",
                  "minimum_time": "0",
                  "maximum_time": "604800",
                  "id": 1,
                  "blurb": "My blurb"
                },
                {
                  "last_move_on": "2013-08-12 09:51:38.665584",
                  "created": "2013-08-12 09:51:38.665570",
                  "title": "Too Many Chefs",
                  "minimum_time": "0",
                  "maximum_time": "604800",
                  "id": 3,
                  "blurb": "How can they avoid spoiling the broth?"
                }
              ],
              "page": "1",
              "pages": "1"
            }

        :param question_id: question id
        :type question_id: int
        :param room: room title
        :type room: string
        :query page: page number. default is 1
        :statuscode 200: no error
        :statuscode 404: there's no user
    '''
    app.logger.debug("api_get_questions called...\n")

    if question_id is not None:

        question = models.Question.query.get(int(question_id))
        if question is None:
            return jsonify("Question not found"), 404

        results = question.get_public()

        # Test for jsonp request
        if 'callback' in request.args:
            d = json.dumps(dict(question=results))
            return request.args['callback'] + '(' + d + ');', 200

        return jsonify(question=results), 200

    else:
        page = int(request.args.get('page', 1))

        room = request.args.get('room', '')
        app.logger.debug('api_get_questions: fetch questions for room %s', room)

        # Filter questions
        query = models.Question.query
        # query = query.filter_by(room=room)
        query = query.filter(id >= 141)
        query = query.order_by(models.Question.last_move_on.desc())
        questions = query.paginate(page,
                                   RESULTS_PER_PAGE,
                                   False)

        items = len(questions.items)
        pages = questions.pages
        total_items = questions.total

        results = []
        for q in questions.items:
            results.append(q.get_public())

        # Test for jsonp request
        if 'callback' in request.args:
            d = json.dumps(dict(total_items=str(total_items), items=str(items),
                           page=str(page), pages=str(pages),
                           questions=results))
            return request.args['callback'] + '(' + d + ');', 200

        return jsonify(total_items=total_items, items=str(items),
                       page=str(page), pages=str(pages),
                       questions=results), 200


#
# Create Question
#
@app.route('/api/v1/questions', methods=['POST'])
@requires_auth
def api_create_question():
    '''
    .. http:post:: /questions

        Create a question.

        **Example request**:

        .. sourcecode:: http

            POST /questions HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
                "url": "/questions/1"
            }

        :json title: question title
        :json blurb: question content
        :json room: question room
        :json minimum_time: minimum time before question can be moved on
        :json maximum_time: maximum time before question is automatically moved on
        :statuscode 201: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_create_question called...\n")

    user = get_authenticated_user(request)
    if not user:
        response = {"message": "User not logged in"}
        return jsonify(response), 400

    app.logger.debug("Authenticated User = %s\n", user.id)

    if not request.json:
        app.logger.debug("Non json request received...\n")
        response = {message: "No question data received"}
        return jsonify(response), 400

    if not 'title' in request.json or request.json['title'] == ''\
            or len(request.json['title']) > MAX_LEN_QUESTION_TITLE:
        response = {message: "Question title must not be empty and no longer than " + str(MAX_LEN_QUESTION_BLURB) + " characters"}
        return jsonify(response), 400

    elif not 'blurb' in request.json or request.json['blurb'] == ''\
            or len(request.json['blurb']) > MAX_LEN_QUESTION_BLURB:
        # abort(400)
        response = {message: "Question text must not be empty and no longer than " + str(MAX_LEN_QUESTION_BLURB) + " characters"}
        return jsonify(response), 400

    elif 'room' in request.json and request.json['room'] != ''\
         and (len(request.json['room']) > MAX_LEN_ROOM
              or len(request.json['room']) < MIN_LEN_ROOM):
        return jsonify(message="Room name must longer than " + str(MIN_LEN_ROOM) + " and less than " + str(MAX_LEN_ROOM) + " characters"), 400

    # Set required parameters
    title = request.json.get('title')
    blurb = request.json.get('blurb')
    # Set optional parameters
    room = request.json.get('room', None)
    minimum_time = request.json.get('minimum_time', 86400)
    maximum_time = request.json.get('maximum_time', 604800)

    question = models.Question(user,
                               title,
                               blurb,
                               minimum_time,
                               maximum_time,
                               room)
    db_session.add(question)
    db_session.commit()

    # Set default threshold for voting map
    question.thresholds.append(models.Threshold(question))
    db_session.commit()

    # url = {'url': url_for('api_get_questions', question_id=question.id)}
    # return jsonify(url), 201

    return jsonify(question=question.get_public()), 201


@app.route('/api/v1/questions/<int:question_id>/subscribers', methods=['GET'])
def api_question_subscribers(question_id=None):
    '''
    .. http:get:: /questions/(int:question_id)/subscribers

        A list of question subscribers.

        **Example request**:

        .. sourcecode:: http

            GET questions/3/subscribers HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "objects": [
                {
                  "url": "/users/1/subscriptions/3",
                  "how": "weekly",
                  "last_update": "None",
                  "question_id": "3"
                },
                {
                  "url": "/users/5/subscriptions/3",
                  "how": "daily",
                  "last_update": "None",
                  "question_id": "3"
                }
              ],
              "num_items": "2",
              "items": 2,
              "question_id": "3",
              "page": "1",
              "pages": "1"
            }

        :param question_id: question id
        :type question_id: int
        :query page: page number, default is 1
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_question_subscribers called with %s...\n",
                     question_id)

    if question_id is None:
        app.logger.debug("ERROR: question_id is None!\n")
        abort(404)

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        abort(404)

    page = int(request.args.get('page', 1))
    # subscribers = question.subscriber_update.\
        # paginate(page, RESULTS_PER_PAGE, False)
    subscribers = models.Update.query.filter_by(question_id=question.id).\
        paginate(page, RESULTS_PER_PAGE, False)

    items = len(subscribers.items)
    pages = subscribers.pages

    results = []
    for s in subscribers.items:
        results.append(s.get_public())

    return jsonify(question_id=str(question.id),
                   items=(items), page=str(page), pages=str(pages),
                   num_items=str(subscribers.total), objects=results), 200

# Get question proposals (Fetch Proposals)
#
# Add options to return only pareto, ingerited or new user proposals
#
@app.route('/api/v1/questions/<int:question_id>/proposals', methods=['GET'])
@app.route('/api/v1/questions/<int:question_id>/proposals/<int:proposal_id>',
           methods=['GET'])
def api_get_question_proposals(question_id=None, proposal_id=None):
    '''
    .. http:get:: /questions/(int:question_id)/proposals/(int:proposal_id)

        A proposal or list of proposals.

        **Example request**:

        .. sourcecode:: http

            GET /questions/22/proposals HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
                "total_items": "4",
                "items": "2",
                "proposals": [
                {
                  "question_url": "/api/v1/questions/1",
                  "author_url": "/api/v1/users/3",
                  "title": "Bills First Proposal",
                  "url": "/api/v1/questions/1/proposals/1",
                  "abstract": null,
                  "created": "2013-08-15 18:32:00.154844",
                  "id": "1",
                  "blurb": "Bills blurb of varying interest",
                  "generation_created": "1"
                },
                {
                  "question_url": "/api/v1/questions/1",
                  "author_url": "/api/v1/users/3",
                  "title": "Bills Second Proposal",
                  "url": "/api/v1/questions/1/proposals/2",
                  "abstract": "This is too abstract for an abstract",
                  "created": "2013-08-15 18:32:00.176816",
                  "id": "2",
                  "blurb": "Bills blurb of varying disinterest",
                  "generation_created": "1"
                }
                ],
                "page": "1",
                "pages": "2"
            }

        :param question_id: question ID
        :type question_id: int
        :param proposal_id: proposal ID
        :type proposal_id: int
        :query generation: question generation, default is current
        :query page: page number, default is 1
        :query user_only: boolean, default false
        :query inherited_only: boolean, default is false
        :statuscode 200: no error
        :statuscode 404: there's no proposal
    '''
    app.logger.debug("api_get_question_proposals called...\n")

    # See if user logged in
    app.logger.debug("Request: %s", request)
    if request.authorization:
        app.logger.debug("Request Authorization IS SET: %s", request.authorization)
    else:
        app.logger.debug("Request Authorization NOT SET")

    # if 'request.json' in locals() or 'request.json' in globals():
    #    app.logger.debug("BOOM!!!")

    user = get_authenticated_user(request)
    app.logger.debug("Got user...")
    if user:
        app.logger.debug("User logged in %s", user.username)
    else:
        app.logger.debug("User not logged in")
    # user = None

    if question_id is None:
        app.logger.debug("ERROR: question_id is None!\n")
        return jsonify(message="question_id not set"), 404

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        return jsonify(message="Question not found"), 404

    if not proposal_id is None:
        proposal_id = int(proposal_id)
        proposal = question.proposals.filter_by(id=proposal_id).one()
        if proposal is None:
            return jsonify(message="Proposal not found"), 404

        result = proposal.get_public()

        # Test for jsonp request
        if 'callback' in request.args:
            d = json.dumps(dict(proposal=result))
            return request.args['callback'] + '(' + d + ');', 200
        else:
            return jsonify(proposal=result), 200

    else:
        generation = int(request.args.get('generation', question.generation))
        page = int(request.args.get('page', 1))

        # proposals = models.Proposal.query.join(models.QuestionHistory).\
        #    filter(models.QuestionHistory.question_id == question.id).\
        #    filter(models.QuestionHistory.generation == generation).\
        #    paginate(page, RESULTS_PER_PAGE, False)

        user_only = request.args.get('user_only', False)
        # Return empty list if user_only requested and user not authenticated
        if user_only and not user:
            app.logger.debug("api_get_question_proposals: user_only True but no current user, return empty list")
            return jsonify(total_items=str(0), items=str(0),
                          page=str(1), pages=str(1),
                          proposals=[]), 200

        inherited_only = request.args.get('inherited_only', False)
        # Return empty list if inherited_only requested and in first generation
        if inherited_only and question.generation == 1:
            return jsonify(total_items=str(0), items=str(0),
                          page=str(1), pages=str(1),
                          proposals=[]), 200

        query = models.Proposal.query.join(models.QuestionHistory).\
            filter(models.QuestionHistory.question_id == question.id).\
            filter(models.QuestionHistory.generation == generation)

        if user and user_only:
            app.logger.debug("api_get_question_proposals: user_only True, add user filter")
            query = query.filter(models.Proposal.user_id == user.id)

        elif inherited_only:
            query = query.filter(models.Proposal.generation_created < question.generation)

        proposals = query.paginate(page, RESULTS_PER_PAGE, False)

        items = len(proposals.items)
        pages = proposals.pages
        total_items = proposals.total

        results = []
        for p in proposals.items:
            results.append(p.get_public(user))

        # Test for jsonp request
        if 'callback' in request.args:
            d = json.dumps(dict(total_items=str(total_items), items=str(items),
                           page=str(page), pages=str(pages),
                           proposals=results))
            return request.args['callback'] + '(' + d + ');', 200
        else:
            # Return json
            return jsonify(total_items=str(total_items), items=str(items),
                          page=str(page), pages=str(pages),
                          proposals=results), 200


# Support Comment
@app.route(
    '/api/v1/questions/<int:question_id>/proposals/' +
    '<int:proposal_id>/comments/<int:comment_id>/support',
    methods=['POST'])
@requires_auth
def api_support_proposal_comment(question_id, proposal_id, comment_id):
    '''
    .. http:post:: /questions/(int:question_id)/proposals/(int:proposal_id)/comments/(int:comment_id)/support

        Update a comment.

        **Example request**:

        .. sourcecode:: http

            POST /questions/45/proposals/47/comments/77/support HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
                 "message": "Support Added"
            }

        :param question_id: question ID
        :type question_id: int
        :param proposal_id: proposal ID
        :type proposal_id: int
        :param comment_id: comment ID
        :type comment_id: int
        :statuscode 200: no error
        :statuscode 400: bad request
        :statuscode 401: unauthorized
        :statuscode 404: not found
    '''
    app.logger.debug("api_support_proposal_comment called...\n")

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    app.logger.debug("Authenticated User = %s\n", user.id)

    if question_id is None or proposal_id is None or comment_id is None:
        return jsonify("URI parameters missing"), 400

    question = models.Question.query.get(int(question_id))
    if question is None:
        return jsonify("Question not found"), 404

    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        return jsonify("Proposal not found"), 404

    comment = models.Comment.query.get(int(comment_id))
    if comment is None:
        return jsonify("Comment not found"), 404

    # Support comment
    user.support_comments([comment])
    db_session.add(user)
    db_session.commit()

    # Return updated supporters list
    supporters = comment.fetch_supporter_ids()
    return jsonify(message="Support added",
                   supporters=str(supporters)), 201


# Unsupport Comment
@app.route(
    '/api/v1/questions/<int:question_id>/proposals/' +
    '<int:proposal_id>/comments/<int:comment_id>/support',
    methods=['DELETE'])
@requires_auth
def api_unsupport_proposal_comment(question_id, proposal_id, comment_id):
    '''
    .. http:delete:: /questions/(int:question_id)/proposals/(int:proposal_id)/comments/(int:comment_id)/support

        Update a comment.

        **Example request**:

        .. sourcecode:: http

            DELETE /questions/45/proposals/47/comments/77/support HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
                 "message": "Support Removed"
            }

        :param question_id: question ID
        :type question_id: int
        :param proposal_id: proposal ID
        :type proposal_id: int
        :param comment_id: comment ID
        :type comment_id: int
        :statuscode 200: no error
        :statuscode 400: bad request
        :statuscode 401: unauthorized
        :statuscode 404: not found
    '''
    app.logger.debug("api_unsupport_proposal_comment called...\n")

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    app.logger.debug("Authenticated User = %s\n", user.id)

    if question_id is None or proposal_id is None or comment_id is None:
        return jsonify("URI parameters missing"), 400

    question = models.Question.query.get(int(question_id))
    if question is None:
        return jsonify("Question not found"), 404

    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        return jsonify("Proposal not found"), 404

    comment = models.Comment.query.get(int(comment_id))
    if comment is None:
        return jsonify("Comment not found"), 404

    # Support comment
    user.unsupport_comments([comment])
    db_session.add(user)
    db_session.commit()

    # Return updated supporters list
    supporters = comment.fetch_supporter_ids()
    app.logger.debug("Updated supporters list==> %s", supporters)
    return jsonify(message="Support removed",
                   supporters=str(supporters)), 201


#
# Get Comments
#
@app.route(
    '/api/v1/questions/<int:question_id>/proposals/' +
    '<int:proposal_id>/comments',
    methods=['GET'])
@app.route(
    '/api/v1/questions/<int:question_id>/proposals/' +
    '<int:proposal_id>/comments/<int:comment_id>',
    methods=['GET'])
# @requires_auth
def api_get_proposal_comments(question_id, proposal_id, comment_id=None):
    '''
    .. http:get:: /questions/(int:question_id)/proposals/(int:proposal_id)/comments/(int:comment_id)

        A user or list of comments.

        **Example request**:

        .. sourcecode:: http

            GET /questions/45/proposals/47/comments HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
               "total_items": 2,
                "items": "2",
                "comments": [
                    {
                      "comment": "This is terrible!",
                      "generation": "1",
                      "question_url": "/api/v1/questions/1",
                      "author_url": "/api/v1/users/1",
                      "comment_type": "oppose",
                      "created": "2013-10-21 15:43:17.558333",
                      "url": "/api/v1/questions/1/proposals/4/comments/1",
                      "proposal_url": "/api/v1/questions/1/proposals/4",
                      "id": "1"
                    },
                    {
                      "comment": "I feel very confused!",
                      "generation": "1",
                      "question_url": "/api/v1/questions/1",
                      "author_url": "/api/v1/users/3",
                      "comment_type": "confused",
                      "created": "2013-10-21 15:43:17.695875",
                      "url": "/api/v1/questions/1/proposals/4/comments/2",
                      "proposal_url": "/api/v1/questions/1/proposals/4",
                      "id": "2"
                    }
                ]
            }

        :param question_id: question id
        :type question_id: int
        :param proposal_id: proposal id
        :type proposal_id: int
        :param comment_id: comment id
        :type comment_id: int or None
        :statuscode 200: no error
        :statuscode 404: there's no user
    '''
    app.logger.debug("api_get_comments called...\n")

    # Get authenticated user or None
    user = get_authenticated_user(request)
    #if not user:
    #    abort(401)

    if question_id is None or proposal_id is None:
        message = {"message": "Question or proposal ids not set"}
        return jsonify(message), 400

    question = models.Question.query.get(int(question_id))
    if question is None:
        message = {"message": "Question not found"}
        return jsonify(message), 404

    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        message = {"message": "Proposal not found"}
        return jsonify(message), 404

    if comment_id is not None:
        comment = models.Comment.query.get(int(comment_id))
        if comment is None:
            message = {"message": "Comment not found"}
            return jsonify(message), 404

        result = comment.get_public()

        return jsonify(comment=result), 200

    else:
        generation = None
        if generation in request.args:
            generation = int(request.args['generation'])

        app.logger.debug("Get Comments: generation = %s", generation)
        
        comments = proposal.get_comments(generation)

        items = len(comments)
        total_items = len(comments)

        results = []
        for c in comments:
            results.append(c.get_public())

        return jsonify(total_items=total_items, items=str(items),
                       comments=results), 200


# Update comment if no other support
#
@app.route(
    '/api/v1/questions/<int:question_id>/proposals/' +
    '<int:proposal_id>/comments/<int:comment_id>',
    methods=['PATCH'])
@requires_auth
def api_update_proposal_comment(question_id, proposal_id, comment_id):
    '''
    .. http:patch:: /questions/(int:question_id)/proposals/(int:proposal_id)/comments/(int:comment_id)

        Update a comment.

        **Example request**:

        .. sourcecode:: http

            PATCH /questions/45/proposals/47/comments/77 HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
                 "message": "Comment Updated"
            }

        :param question_id: question ID
        :type question_id: int
        :param proposal_id: proposal ID
        :type proposal_id: int
        :param comment_id: comment ID
        :type comment_id: int
        :json comment_type: one of endorse, oppose or confused
        :json new_comment: text for new comment
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_add_proposal_comment called...\n")

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    app.logger.debug("Authenticated User = %s\n", user.id)

    if question_id is None or proposal_id is None:
        abort(404)

    question = models.Question.query.get(int(question_id))
    if question is None:
        abort(400)

    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        abort(400)

    comment = models.Comment.query.get(int(comment_id))
    if comment is None:
        return jsonify("Comment not found"), 400

    # Only the author can edit a comment
    if comment.user_id != user.id:
        return jsonify("Only the author can edit a comment"), 403

    # Make sure there are no other supportes (other than author)
    supporters = comment.supporters.all()
    if len(supporters) != 1 and supporters[0] != user:
        return jsonify("Comment supported by other users cannot be edited."), 403

    app.logger.debug("request.json = %s\n", request.json)

    if not 'comment_type' in request.json or not request.json['comment_type'] in COMMENT_TYPES:
        message = {"message": "comment_type must be one of endorse, oppose or confused"}
        return jsonify(message), 400

    comment_type = request.json['comment_type']

    new_comment_text = None
    if 'new_comment_text' in request.json:
        if request.json['new_comment_text'] == '' \
                or len(request.json['new_comment_text']) > MAX_LEN_PROPOSAL_COMMENT:
            message = {"message": "Comment text must be no longer than " + MAX_LEN_PROPOSAL_COMMENT + " characters"}
            return jsonify(message), 400
        else:
            new_comment_text = request.json['new_comment_text']

    app.logger.debug("comment_type = %s\n", comment_type)
    app.logger.debug("new_comment_text = %s\n", new_comment_text)

    # Check if update details are identical to existing details
    if comment_type == comment.comment_type and comment.comment == new_comment_text:
        return jsonify("Update matches original"), 409

    # Check if duplcate comment already exists
    existing_comment = models.Comment.fetch_if_exists(proposal, new_comment_text, comment_type)
    if (existing_comment and existing_comment.id != comment.id):
        return jsonify("Identical comment found"), 400

    # Everything OK - update comment
    comment.comment = new_comment_text
    comment.comment_type = comment_type
    db_session.commit()
    return jsonify(message="Comment updated"), 201


# Create Comment
#
@app.route(
    '/api/v1/questions/<int:question_id>/proposals/' +
    '<int:proposal_id>/comments',
    methods=['POST'])
@requires_auth
def api_add_proposal_comment(question_id, proposal_id):
    '''
    .. http:post:: /questions/(int:question_id)/proposals/(int:proposal_id)/comments

        Add a comment.

        **Example request**:

        .. sourcecode:: http

            POST /questions/45/proposals/47/comments HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
                 "message": "Comment added"
            }

        :param question_id: question ID
        :type question_id: int
        :param proposal_id: proposal ID
        :type proposal_id: int
        :json comment_type: one of endorse, oppose or confused
        :json new_comment: text for new comment
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_add_proposal_comment called...\n")

    user = get_authenticated_user(request)
    if not user:
        # abort(401)
        message = {"message": "You need to be logged in to post a comment"}
        return jsonify(message), 401

    app.logger.debug("Authenticated User = %s\n", user.id)

    if question_id is None or proposal_id is None:
        abort(404)

    question = models.Question.query.get(int(question_id))
    if question is None:
        message = {"message": "Question not found"}
        return jsonify(message), 400

    # Consider allowing comments during writing
    elif question.phase != 'voting':
        message = {"message": "The question is not in the voting phase"}
        return jsonify(message), 403

    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        message = {"message": "Proposal not found"}
        return jsonify(message), 400

    app.logger.debug("request.json = %s\n", request.json)

    if not 'comment_type' in request.json or not request.json['comment_type'] in COMMENT_TYPES:
            message = {"message": "comment_type must be one of for, against, question or answer"}
            return jsonify(message), 400

    comment_type = request.json['comment_type']

    comment = None
    if 'comment' in request.json:
        if request.json['comment'] == '' \
                or len(request.json['comment']) > MAX_LEN_PROPOSAL_COMMENT:
            message = {"message": "Comment text must be no longer than " + MAX_LEN_PROPOSAL_COMMENT + " characters"}
            return jsonify(message), 400
        else:
            comment = request.json['comment']
    else:
        message = {"message": "No comment text passed"}
        return jsonify(message), 400

    reply_to = 0
    if 'reply_to' in request.json:
        try:
            reply_to = int(request.json['reply_to'])
        except:
            app.logger.debug('Failed to convert reply_to param to integer')
            reply_to = 0

    app.logger.debug("comment_type = %s\n", comment_type)
    app.logger.debug("comment = %s\n", comment)
    app.logger.debug("reply_to = %s\n", reply_to)

    # List of supported comments
    comment_id = None
    new_comment = None

    # Fetch the comment which matches comment text or create new one
    if (comment):
        existing_comment = models.Comment.fetch_if_exists(proposal, comment, comment_type)
        if (existing_comment):
            message = {"message": "Comment already exists for this proposal"}
            return jsonify(message), 400
        else:
            new_comment = models.Comment(user, proposal, comment, comment_type, reply_to)
            if (new_comment is False):
                return jsonify(message="Could not create comment"), 500
            else:
                db_session.add(new_comment)
                db_session.commit()
                user.support_comment(new_comment)
                db_session.commit()
                response = new_comment.get_public()
                response['question_count'] = str(proposal.get_question_count())
                response['comment_count'] = str(proposal.get_comment_count())
                return jsonify(comment=response), 201


# Delete comment (if unsupported by anyone else)
@app.route(
    '/api/v1/questions/<int:question_id>/proposals/' +
    '<int:proposal_id>/comments/<int:comment_id>',
    methods=['DELETE'])
@requires_auth
def api_delete_proposal_comment(question_id, proposal_id, comment_id):
    '''
    .. http:delete:: /questions/(int:question_id)/proposals/(int:proposal_id)/comments/(int:comment_id)

        Delete a comment.

        **Example request**:

        .. sourcecode:: http

            DELETE /questions/45/proposals/47/comments/77 HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
                 "message": "Comment deleted"
            }

        :param question_id: question ID
        :type question_id: int
        :param proposal_id: proposal ID
        :type proposal_id: int
        :param comment_id: comment ID
        :type comment_id: int
        :statuscode 201: no error
        :statuscode 400: bad request
        :statuscode 401: unauthorized
        :statuscode 404: not found
    '''
    app.logger.debug("api_delete_proposal_comment called...\n")

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    app.logger.debug("Authenticated User = %s\n", user.id)

    if question_id is None or proposal_id is None or comment_id is None:
        return jsonify("URI parameters missing"), 400

    question = models.Question.query.get(int(question_id))
    if question is None:
        return jsonify("Question not found"), 404

    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        return jsonify("Proposal not found"), 404

    comment = models.Comment.query.get(int(comment_id))
    if comment is None:
        return jsonify("Comment not found"), 404

    if comment.supporters.count() > 1:
        return jsonify("Comment has other supporters so cannot be deleted"), 404

    # Unsupport comment
    user.unsupport_comments([comment])
    db_session.add(user)
    db_session.commit()

    # Delete comment
    proposal.comments.remove(comment)
    db_session.commit()
    return jsonify(message="Comment deleted"), 201


# Create Endorsement
#
@app.route(
    '/api/v1/questions/<int:question_id>/proposals/' +
    '<int:proposal_id>/endorsements',
    methods=['POST'])
@requires_auth
def api_add_proposal_endorsement(question_id, proposal_id):
    '''
    .. http:post:: /questions/(int:question_id)/proposals/(int:proposal_id)/endorsements

        Endorse a proposal.

        **Example request**:

        .. sourcecode:: http

            POST /questions/45/proposals/47/endorsements HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
                 "message": "Endorsement added"
            }

        :param question_id: question ID
        :type question_id: int
        :param proposal_id: proposal ID
        :type proposal_id: int
        :json endorsement_type: one of endorse, oppose or confused
        :json comments: ids of supported comments
        :json new_comment: text for new comment
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_add_proposal_endorsement called...\n")

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    app.logger.debug("Authenticated User = %s\n", user.id)

    if question_id is None or proposal_id is None:
        abort(404)

    question = models.Question.query.get(int(question_id))
    if question is None:
        abort(400)

    elif question.phase != 'voting':
        message = {"message": "The question is not in the voting phase"}
        return jsonify(message), 403

    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        abort(400)

    app.logger.debug("request.json = %s\n", request.json)

    '''
    We either use an endorsement type returned from the client to set the endorsement or
    the NORMALISED coordinates from the triangular votemap when compared to the
    threshold for the current generation of this question.
    '''

    # Check if using votemap to calculate endorsement type
    if 'use_votemap' in request.json and request.json['use_votemap']:
        app.logger.debug('Endorsing using votemap coordinates')
        # Check for coords

        if not 'coords' in request.json:
            message = {"message": "Using votemap: No votemap coordinates received"}
            return jsonify(message), 403

        coords = request.json['coords']

        if not coords['mapx'] or not coords['mapy']:
            message = {"message": "Using votemap: No votemap coordinates received"}
            return jsonify(message), 403

        # Calculate endorsement type from coords
        mapx = float(coords['mapx'])
        mapy = float(coords['mapy'])

        # Fetch current threshold coordinates for this generation
        threshold = question.thresholds\
            .filter(models.Threshold.generation == question.generation).one()

        if not threshold:
            app.logger.debug('No threshold found for question! Database out of date?')
            message = {"message": "No threshold was found for this question"}
            return jsonify(message), 500

        if mapy > threshold.mapy:
            endorsement_type = 'confused';
        elif mapx < threshold.mapx:
            endorsement_type = 'oppose';
        else:
            endorsement_type = 'endorse';

        # Add user endorsement
        proposal.endorse(user, endorsement_type, coords=coords)
        db_session.commit()
    else:
        app.logger.debug('Endorsing using supplied endorsement type')
        if not 'endorsement_type' in request.json:
            message = {"message": "You must set endorsement_type if not using votemap coordinates"}
            return jsonify(message), 400
        elif not request.json['endorsement_type'] in ENDORSEMENT_TYPES:
            message = {"message": "endorsement_type must be one of endorse, oppose or confused"}
            return jsonify(message), 400
        else:
            app.logger.debug("Endrsing type json parameter == %s", request.json['endorsement_type'])
            endorsement_type = request.json['endorsement_type']
            # Add user endorsement
            proposal.endorse(user, endorsement_type)
            db_session.commit()

    '''
    # Update graphs
    question.get_voting_graph(
        generation=generation,
        map_type='all')
    question.get_voting_graph(
        generation=generation,
        map_type='all')
    '''

    return jsonify(message="Endorsement added",
                   endorsement_type=endorsement_type), 201



# Create Endorsement
#
@requires_auth
def api_add_proposal_endorsement_v1(question_id, proposal_id):
    '''
    .. http:post:: /questions/(int:question_id)/proposals/(int:proposal_id)/endorsements

        Endorse a proposal.

        **Example request**:

        .. sourcecode:: http

            POST /questions/45/proposals/47/endorsements HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
                 "message": "Endorsement added"
            }

        :param question_id: question ID
        :type question_id: int
        :param proposal_id: proposal ID
        :type proposal_id: int
        :json endorsement_type: one of endorse, oppose or confused
        :json comments: ids of supported comments
        :json new_comment: text for new comment
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_add_proposal_endorsement called...\n")

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    app.logger.debug("Authenticated User = %s\n", user.id)

    if question_id is None or proposal_id is None:
        abort(404)

    question = models.Question.query.get(int(question_id))
    if question is None:
        abort(400)

    elif question.phase != 'voting':
        message = {"message": "The question is not in the voting phase"}
        return jsonify(message), 403

    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        abort(400)

    # if proposal.is_endorsed_by(user):
    #    message = {"message": "User has already endorsed this proposal"}
    #    return jsonify(message), 400

    app.logger.debug("request.json = %s\n", request.json)

    endorsement_type = 'endorse'
    if 'endorsement_type' in request.json:
        if not request.json['endorsement_type'] in ENDORSEMENT_TYPES:
            message = {"message": "endorsement_type must be one of endorse, oppose or confused"}
            return jsonify(message), 400
        else:
            app.logger.debug("Endrsing type json parameter == %s", request.json['endorsement_type'])
            endorsement_type = request.json['endorsement_type']

    # add voting map coordinates if any
    coords = request.json.get('coords', {'mapx': None, 'mapy': None})

    app.logger.debug("endorsement_type = %s\n", endorsement_type)
    app.logger.debug("vote coords = %s\n", coords)

    # Add user endorsement
    proposal.endorse(user, endorsement_type, coords=coords)
    db_session.commit()

    '''
    # Update graphs
    question.get_voting_graph(
        generation=generation,
        map_type='all')
    question.get_voting_graph(
        generation=generation,
        map_type='all')
    '''

    return jsonify(message="Endorsement added"), 201


# Update Endorsement
#
@app.route('/api/v1/questions/<int:question_id>/proposals/' +
           '<int:proposal_id>/endorsements',
           methods=['PATCH'])
@requires_auth
def api_update_proposal_endorsement(question_id, proposal_id):
    '''
    .. http:post:: /questions/(int:question_id)/proposals/(int:proposal_id)/endorsements

        Update an endorsement.

        **Example request**:

        .. sourcecode:: http

            DELETE /questions/45/proposals/47/endorsements HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "message": "Endorsement updated"
            }

        :param question_id: question ID
        :type question_id: int
        :param proposal_id: proposal ID
        :type proposal_id: int
        :json endorsement_type: one of endorse, oppose or confused
        :statuscode 200: no error
        :statuscode 400: bad request
        :statuscode 500: server error
    '''
    app.logger.debug("api_update_proposal_endorsement called...\n")

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    app.logger.debug("Authenticated User = %s\n", user.id)

    if question_id is None or proposal_id is None:
        message = {"message": "Your request is missing parameters"}
        return jsonify(message), 404

    question = models.Question.query.get(int(question_id))
    if question is None:
        abort(400)
    elif question.phase != 'voting':
        message = {"message": "The question is not in the voting phase"}
        return jsonify(message), 403

    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        abort(400)

    if not proposal.is_endorsed_by(user):
        message = {"message": "User has not yet endorsed this proposal"}
        return jsonify(message), 400

    if not 'endorsement_type' in request.json or not request.json['endorsement_type'] in ENDORSEMENT_TYPES:
        message = {"message": "endorsement_type must be one of endorse, oppose or confused"}
        return jsonify(message), 400

    update_proposal = proposal.update_endorsement(user, request.json['endorsement_type'])

    if update_proposal:
        return jsonify(message="Endorsement updated"), 200
    else:
        return jsonify(message="Failed to update endorsement"), 500


# Remove Endorsement - TO REMOVE
#
# @app.route('/api/v1/questions/<int:question_id>/proposals/' +
#           '<int:proposal_id>/endorsements',
#           methods=['DELETE'])
@requires_auth
def api_remove_proposal_endorsement(question_id, proposal_id):
    '''
    .. http:post:: /questions/(int:question_id)/proposals/(int:proposal_id)/endorsements

        Delete an endorsement.

        **Example request**:

        .. sourcecode:: http

            DELETE /questions/45/proposals/47/endorsements HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "message": "Endorsement removed"
            }

        :param question_id: question ID
        :type question_id: int
        :param proposal_id: proposal ID
        :type proposal_id: int
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_remove_proposal_endorsement called...\n")

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    app.logger.debug("Authenticated User = %s\n", user.id)

    if question_id is None or proposal_id is None:
        abort(404)

    question = models.Question.query.get(int(question_id))
    if question is None:
        abort(400)
    elif question.phase != 'voting':
        message = {"message": "The question is not in the voting phase"}
        return jsonify(message), 403

    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        abort(400)

    if not proposal.is_endorsed_by(user):
        message = {"message": "User has not yet endorsed this proposal"}
        return jsonify(message), 400

    proposal.remove_endorsement(user)
    db_session.commit()

    return jsonify(message="Endorsement removed"), 200


#
# Create proposal
#
@app.route('/api/v1/questions/<int:question_id>/proposals', methods=['POST'])
@requires_auth
def api_create_proposal(question_id):
    '''
    .. http:post:: /questions/(int:question_id)/proposals

        Create a proposal.

        **Example request**:

        .. sourcecode:: http

            POST /questions/45/proposals HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
                "url": "/api/v1/questions/45/proposals/1"
            }

        :param question_id: question ID
        :type question_id: int
        :json title: proposal title
        :json blurb: proposal content
        :json abstract: proposal abstract
        :json source: parent proposal ID
        :statuscode 201: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_create_proposal called...\n")

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    app.logger.debug("Authenticated User = %s\n", user.id)

    if question_id is None:
        abort(400)

    question = models.Question.query.get(int(question_id))
    if question is None:
        abort(400)

    if not request.json:
        app.logger.debug("Non json request received...\n")
        abort(400)

    if not 'title' in request.json or request.json['title'] == ''\
            or len(request.json['title']) > MAX_LEN_PROPOSAL_TITLE:
        return jsonify(message="Proposal title must not be empty and must be less than " + str(MAX_LEN_PROPOSAL_ABSTRACT) + " characters"), 400

    elif not 'blurb' in request.json or request.json['blurb'] == ''\
            or len(request.json['blurb']) > MAX_LEN_PROPOSAL_BLURB:
        return jsonify(message="Proposal content must not be empty and must be less than " + str(MAX_LEN_PROPOSAL_ABSTRACT) + " characters"), 400

    elif 'abstract' in request.json and \
            len(request.json['abstract']) > MAX_LEN_PROPOSAL_ABSTRACT:
        return jsonify(message="Proposal abstract name must less than " + str(MAX_LEN_PROPOSAL_ABSTRACT) + " characters"), 400

    title = request.json.get('title')
    blurb = request.json.get('blurb')
    abstract = request.json.get('abstract', None)

    source = 0
    if 'source' in request.json:
        if not isinstance(request.json['source'], int):
            message = {"message": "source parameter invalid"}
            return jsonify(message), 400
        elif not models.Proposal.query.get(int(request.json['source'])):
            message = {"message": "source proposal not found"}
            return jsonify(message), 400
        else:
            source = request.json['source']

    proposal = models.Proposal(user, question, title, blurb, abstract, source)
    db_session.add(proposal)
    db_session.commit()

    return jsonify(proposal=proposal.get_public()), 201


# Delete proposal
#
@app.route('/api/v1/questions/<int:question_id>/proposals/<int:proposal_id>',
           methods=['DELETE'])
@requires_auth
def api_delete_proposal(question_id, proposal_id):
    '''
    .. http:delete:: questions/(int:question_id)/proposals/(int:proposal_id)

        Delete a proposal.

        **Example request**:

        .. sourcecode:: http

            DELETE questions/34/proposals/77 HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
             "message": "Proposal deleted"
            }

        :param question_id: question id
        :type question_id: int
        :param proposal_id: proposal id
        :type proposal_id: int
        :statuscode 201: no error
        :statuscode 400: bad request
        :statuscode 401: user not authorized
        :statuscode 403: action forbidden
        :statuscode 404: question or proposal not found
    '''
    app.logger.debug("api_delete_proposal called...\n")

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    app.logger.debug("Authenticated User = %s\n", user.id)

    if question_id is None or proposal_id is None:
        abort(404)

    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        abort(404)

    if user.id != proposal.user_id:
        message = {"message": "You are not authorized to delete this proposal"}
        return jsonify(message), 403

    if proposal.question.phase != 'writing'\
            or proposal.question.generation != proposal.generation_created:
        message = {"message": "This proposal may no longer be deleted"}
        return jsonify(message), 403

    user.delete_proposal(proposal)
    db_session.commit()
    return jsonify(message="Proposal deleted"), 200


# Delete Question
#
@app.route('/api/v1/questions/<int:question_id>', methods=['DELETE'])
@requires_auth
def api_delete_question(question_id):
    '''
    .. http:post:: /questions/(int:question_id)

        Delete a question.

        **Example request**:

        .. sourcecode:: http

            POST /questions/34 HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "message": "Question deleted"
            }

        :param question_id: question ID
        :type question_id: int
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_delete_question called for question %s...\n",
                     question_id)

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    app.logger.debug("Authenticated User = %s\n", user.id)

    if 'question_id' is None:
        abort(404)

    question = models.Question.query.get(int(question_id))
    if question is None:
        abort(404)

    # Cannot delete a question if not author
    if user.id != question.user_id:
        message = {"message":
                   "You are not authorized to delete this question"}
        return jsonify(message), 403

    # Cannot delete a question which has proposals
    if question.proposals.count() > 0:
        message = {"message":
                   "This question has proposals and may no longer be deleted"}
        return jsonify(message), 403

    db_session.delete(question)
    db_session.commit()
    return jsonify(message="Question deleted"), 200


# Edit Question
#
@app.route('/api/v1/questions/<int:question_id>', methods=['PATCH'])
@requires_auth
def api_edit_question(question_id):
    '''
    .. http:post:: /questions/(int:question_id)

        Update a question.

        **Example request**:

        .. sourcecode:: http

            POST /questions/33 HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
             "message": "Question updated"
            }

        :param question_id: question ID
        :type question_id: int
        :json title: question title
        :json blurb: question content
        :json room: question room
        :json minimum_time: minimum time before question can be moved on
        :json maximum_time: maximum time before question is automatically moved on
        :statuscode 201: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_edit_question called...\n")

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    app.logger.debug("Authenticated User = %s\n", user.id)

    if 'question_id' is None:
        abort(404)

    question = models.Question.query.get(int(question_id))
    if question is None:
        abort(404)

    user_id = user.id

    # Cannot edit a question if not author
    if user_id != question.user_id:
        message = {"message": "You are not authorized to edit this question"}
        return jsonify(message), 403

    if 'move_on' in request.json:
        if not question.minimum_time_passed():
            app.logger.debug("Question cannot be moved on " +
                             "until minimum time has passed")
            message = {"message": "Question cannot be moved on " +
                                  "until minimum time has passed"}
            return jsonify(message), 405

        phase = question.author_move_on(user_id)
        db_session.commit()

        if not phase:
            return 500
        else:
            # message = {"new_phase": phase}
            return jsonify({"question": question.get_public()}), 200

    # Cannot edit a question which has proposals
    if question.propsals.count() > 0:
        message = {"message":
                   "This question has proposals and may no longer be edited"}
        return jsonify(message), 405

    if not 'title' in request.json or request.json['title'] == ''\
            or len(request.json['title']) > MAX_LEN_QUESTION_TITLE:
        abort(400)

    elif not 'blurb' in request.json or request.json['blurb'] == ''\
            or len(request.json['blurb']) > MAX_LEN_QUESTION_BLURB:
        abort(400)

    question.title = request.json.get('title')
    question.blurb = request.json.get('blurb')

    db_session.add(question)
    db_session.commit()
    return jsonify(message="Question updated"), 200


# Edit proposal
#
@app.route('/api/v1/questions/<int:question_id>/proposals/<int:proposal_id>',
           methods=['PATCH'])
@requires_auth
def api_edit_proposal(question_id, proposal_id):
    '''
    .. http:patch:: questions/int:question_id/proposals/int:proposal_id

        Edit proposal.

        **Example request**:

        .. sourcecode:: http

            PATCH questions/22/proposals/14 HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
              "message": "Proposal updated"
            }

        :param question_id: question ID
        :type question_id: int
        :param proposal_id: proposal ID
        :type proposal_id: int
        :json title: title
        :json blurb: question content
        :json abstract: optional abstract
        :statuscode 201: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_edit_proposal called...\n")

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    app.logger.debug("Authenticated User = %s\n", user.id)

    if 'question_id' is None or 'proposal_id' is None:
        abort(404)

    if not 'title' in request.json or request.json['title'] == '' \
            or len(request.json['blurb']) > MAX_LEN_PROPOSAL_TITLE:
        abort(400)

    elif not 'blurb' in request.json or request.json['blurb'] == '' \
            or len(request.json['blurb']) > MAX_LEN_PROPOSAL_BLURB:
        abort(400)

    elif 'abstract' in request.json and \
            (request.json['abstract'] == ''
             or len(request.json['abstract']) > MAX_LEN_PROPOSAL_ABSTRACT):
        abort(400)

    title = request.json.get('title')
    blurb = request.json.get('blurb')
    abstract = request.json.get('abstract', None)

    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        abort(404)

    if user.id != proposal.user_id:
        message = {"message": "You are not authorized to edit this proposal"}
        return jsonify(message), 403

    if proposal.question.phase != 'writing'\
            or proposal.question.generation != proposal.generation_created:
        message = {"message": "This proposal may no longer be edited"}
        return jsonify(message), 403

    if proposal.update(user, title, blurb, abstract):
        db_session.commit()
        message = {"message":
                   "Proposal updated"}
        return jsonify(message), 200
    else:
        message = {"message": "There was an error updating this proposal"}
        return jsonify(message), 400


# Get Proposal Endorsers
@app.route('/api/v1/questions/<int:question_id>/proposals/' +
           '<int:proposal_id>/endorsers',
           methods=['GET'])
def api_get_question_proposal_endorsers(question_id=None, proposal_id=None):
    '''
    .. http:get:: /questions/(int:question_id)/proposals/(int:proposal_id)/endorsers

        A list of proposal endorsers.

        **Example request**:

        .. sourcecode:: http

            GET /questions/42/proposals/67/endorsers HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "query_generation": "1",
              "current_generation": "1",
              "endorsers": [
                {
                  "username": "john",
                  "url": "/users/1",
                  "registered": "2013-08-15 18:10:23.877239",
                  "id": "1",
                  "last_seen": "2013-08-15 18:10:23.877268"
                },
                {
                  "username": "susan",
                  "url": "/users/2",
                  "registered": "2013-08-15 18:10:23.938536",
                  "id": "2",
                  "last_seen": "2013-08-15 18:10:23.938550"
                },
                {
                  "username": "harry",
                  "url": "/users/5",
                  "registered": "2013-08-15 18:10:23.981326",
                  "id": "5",
                  "last_seen": "2013-08-15 18:10:23.981341"
                }
              ],
              "num_items": "3",
              "question_id": "1"
            }

        :param question_id: question id
        :type question_id: int
        :param proposal_id: proposal id
        :type proposal_id: int
        :query generation: question generation, default is 1
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_get_question_proposal_endorsers called...\n")

    if question_id is None or proposal_id is None:
        app.logger.debug("ERROR: question_id or proposal_id is None!\n")
        abort(404)

    question = models.Question.query.get(int(question_id))
    if question is None:
        abort(404)

    proposal = models.Proposal.query.get(int(proposal_id))
    if proposal is None:
        abort(404)

    generation = int(request.args.get('generation', question.generation))
    endorsers = proposal.endorsers(generation=generation)

    results = []
    for e in endorsers:
        results.append(e.get_public())

    return jsonify(question_id=str(question.id),
                   query_generation=str(generation),
                   current_generation=str(question.generation),
                   num_items=str(len(endorsers)), endorsers=results), 200


#
# Get Pareto Front
#
@app.route('/api/v1/questions/<int:question_id>/pareto', methods=['GET'])
def api_question_pareto(question_id=None):
    '''
    .. http:post:: /questions/(int:question_id)/pareto

        The pareto front of a question.

        **Example request**:

        .. sourcecode:: http

            POST /questions/44/proposals HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "query_generation": "1",
              "current_generation": "1",
              "proposals": [
                {
                  "question_url": "/api/v1/questions/1",
                  "author_url": "/api/v1/users/3",
                  "title": "Bills Second Proposal",
                  "url": "/api/v1/questions/1/proposals/2",
                  "abstract": "This is too abstract for an abstract",
                  "created": "2013-08-15 18:32:00.176816",
                  "id": "2",
                  "blurb": "Bills blurb of varying disinterest",
                  "generation_created": "1"
                },
                {
                  "question_url": "/api/v1/questions/1",
                  "author_url": "/api/v1/users/2",
                  "title": "Susans Only Proposal",
                  "url": "/api/v1/questions/1/proposals/3",
                  "abstract": "Blah blah blah",
                  "created": "2013-08-15 18:32:00.194978",
                  "id": "3",
                  "blurb": "My blub is cool",
                  "generation_created": "1"
                },
                {
                  "question_url": "/api/v1/questions/1",
                  "author_url": "/api/v1/users/5",
                  "title": "Harrys Cooler Proposal",
                  "url": "/api/v1/questions/1/proposals/4",
                  "abstract": null,
                  "created": "2013-08-15 18:32:00.228671",
                  "id": "4",
                  "blurb": "Harry edits like a champ",
                  "generation_created": "1"
                }
              ],
              "num_items": "3",
              "question_id": "1"
            }

        :param question_id: question id
        :json username: username
        :json email: email address
        :json password: password
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_question_pareto called with %s...\n", question_id)

    if question_id is None:
        app.logger.debug("ERROR: question_id is None!\n")
        abort(404)

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        abort(404)

    generation = int(request.args.get('generation', question.generation))
    pareto = question.calculate_pareto_front(generation=generation)

    results = []
    for p in pareto:
        results.append(p.get_public())

    return jsonify(question_id=str(question.id),
                   query_generation=str(generation),
                   current_generation=str(question.generation),
                   num_items=str(len(pareto)), proposals=results), 200


@app.route('/api/v1/questions/<int:question_id>/participation_table', methods=['GET'])
def api_question_participation_table(question_id=None):
    '''
    .. http:post:: /questions/(int:question_id)/participation_table

        A list of the Key Players for this round.

        **Example request**:

        .. sourcecode:: http

            POST /questions/44/key_players HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "query_generation": "1",
              "current_generation": "1",
              "key_players": [
                {
                  "3": [
                    "/api/v1/questions/1/proposals/4",
                    "/api/v1/questions/1/proposals/3"
                  ]
                },
                {
                  "4": [
                    "/api/v1/questions/1/proposals/3"
                  ]
                }
              ],
              "num_items": "2",
              "question_id": "1"
            }

        :param question_id: question id
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_question_participation_table called with %s...\n",
                     question_id)

    if question_id is None:
        app.logger.debug("ERROR: question_id is None!\n")
        abort(404)

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        jsonify(message="Question not found"), 404

    participants = set()

    key_players = question.calculate_key_players()
    all_proposals = question.get_all_proposals()

    all_voters = set()
    all_authors = set()
    for proposal in all_proposals:
        all_authors.add(proposal.author)
        all_voters.update(proposal.all_voters())

    participants.update(all_authors)
    participants.update(all_voters)

    app.logger.debug("participants==> %s", participants)

    participation_table = []
    for user in participants:
        participant = dict()
        participant['username'] = user.username
        participant['key_player'] = user in key_players
        participant['past_generations'] = user.generations_participated_count(question)
        participant['evaluations'] = user.get_endorsement_count(question)
        app.logger.debug("participant==>%s", participant)
        participation_table.append(participant)
        app.logger.debug("participation_table==>%s", participation_table)

    return jsonify(question_id=str(question.id),
                   current_generation=str(question.generation),
                   num_proposals=str(len(all_proposals)),
                   num_items=str(len(participation_table)),
                   participation_table=participation_table), 200


@app.route('/api/v1/questions/<int:question_id>/key_players', methods=['GET'])
def api_question_key_players(question_id=None):
    '''
    .. http:post:: /questions/(int:question_id)/key_players

        A list of the Key Players for this round.

        **Example request**:

        .. sourcecode:: http

            POST /questions/44/key_players HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "query_generation": "1",
              "current_generation": "1",
              "key_players": [
                {
                  "3": [
                    "/api/v1/questions/1/proposals/4",
                    "/api/v1/questions/1/proposals/3"
                  ]
                },
                {
                  "4": [
                    "/api/v1/questions/1/proposals/3"
                  ]
                }
              ],
              "num_items": "2",
              "question_id": "1"
            }

        :param question_id: question id
        :json username: username
        :json email: email address
        :json password: password
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_question_key_players called with %s...\n",
                     question_id)

    if question_id is None:
        app.logger.debug("ERROR: question_id is None!\n")
        abort(404)

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        jsonify(message="Question not found"), 404

    generation = int(request.args.get('generation', question.generation))
    key_players = question.calculate_key_players(generation=generation)

    app.logger.debug("calculate_key_players returned: %s", key_players)
    # {3: set([<Proposal('3', Q:'1')>, <Proposal('4', Q:'1')>]), 4: set([<Proposal('3', Q:'1')>])}

    '''
    # Version 1
    results = []
    for (endorser, vote_for) in key_players.iteritems():
        proposals = []
        for proposal in vote_for:
            proposals.append(proposal.id)
        kp = {'user': endorser.get_public(), 'add_vote': proposals}
        results.append(kp)
    '''
    # Version 2
    results = []
    for (endorser, vote_for) in key_players.iteritems():
        # Need to initialize values to stop knockout.js complaining
        proposals = {'notvoted': [], 'oppose': [], 'confused': []}
        for proposal in vote_for:
            endorse_type = proposal.get_endorsement_type(endorser)
            # if endorse_type not in proposals:
                # proposals[endorse_type] = list()
            proposals[endorse_type].append(proposal.id)
        kp = {'user': endorser.get_public(), 'add_vote': proposals}
        results.append(kp)

    return jsonify(question_id=str(question.id),
                   query_generation=str(generation),
                   current_generation=str(question.generation),
                   num_items=str(len(key_players)), key_players=results), 200


#@app.route('/api/v1/questions/<int:question_id>/key_players', methods=['GET'])
def api_question_key_players_v1(question_id=None):
    '''
    .. http:post:: /questions/(int:question_id)/key_players

        A list of the Key Players for this round.

        **Example request**:

        .. sourcecode:: http

            POST /questions/44/key_players HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "query_generation": "1",
              "current_generation": "1",
              "key_players": [
                {
                  "3": [
                    "/api/v1/questions/1/proposals/4",
                    "/api/v1/questions/1/proposals/3"
                  ]
                },
                {
                  "4": [
                    "/api/v1/questions/1/proposals/3"
                  ]
                }
              ],
              "num_items": "2",
              "question_id": "1"
            }

        :param question_id: question id
        :json username: username
        :json email: email address
        :json password: password
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_question_key_players called with %s...\n",
                     question_id)

    if question_id is None:
        app.logger.debug("ERROR: question_id is None!\n")
        abort(404)

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        jsonify(message="Question not found"), 404

    generation = int(request.args.get('generation', question.generation))
    key_players = question.calculate_key_players(generation=generation)

    app.logger.debug("calculate_key_players returned: %s", key_players)
    # {3: set([<Proposal('3', Q:'1')>, <Proposal('4', Q:'1')>]), 4: set([<Proposal('3', Q:'1')>])}

    results = []
    for (endorser, vote_for) in key_players.iteritems():
        proposals = []
        for proposal in vote_for:
            # proposals.append(url_for('api_get_question_proposals',
            #                         question_id=question.id,
            #                         proposal_id=proposal.id))
            proposals.append(proposal.id)
        kp = {endorser: proposals}
        results.append(kp)

    return jsonify(question_id=str(question.id),
                   query_generation=str(generation),
                   current_generation=str(question.generation),
                   num_items=str(len(key_players)), key_players=results), 200


@app.route('/api/v1/questions/<int:question_id>/endorser_effects',
           methods=['GET'])
def api_question_endorser_effects(question_id=None):
    '''
    .. http:post:: /questions/(int:question_id)/endorser_effects

        A list of endorser effects.

        **Example request**:

        .. sourcecode:: http

            POST /questions/44/endorser_effects HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "query_generation": "1",
              "current_generation": "1",
              "objects": [
                {
                  "5": {}
                },
                {
                  "4": {
                    "PF_excluding": [
                      {
                        "question_url": "/api/v1/questions/1",
                        "author_url": "/api/v1/users/2",
                        "title": "Susans Only Proposal",
                        "url": "/api/v1/questions/1/proposals/3",
                        "abstract": "Blah blah blah",
                        "created": "2013-08-15 18:32:00.194978",
                        "id": "3",
                        "blurb": "My blub is cool",
                        "generation_created": "1"
                      }
                    ],
                    "PF_plus": [],
                    "PF_minus": [
                      {
                        "question_url": "/api/v1/questions/1",
                        "author_url": "/api/v1/users/5",
                        "title": "Harrys Cooler Proposal",
                        "url": "/api/v1/questions/1/proposals/4",
                        "abstract": null,
                        "created": "2013-08-15 18:32:00.228671",
                        "id": "4",
                        "blurb": "Harry edits like a champ",
                        "generation_created": "1"
                      }
                    ]
                  }
                },
                {
                  "3": {
                    "PF_excluding": [
                      {
                        "question_url": "/api/v1/questions/1",
                        "author_url": "/api/v1/users/5",
                        "title": "Harrys Cooler Proposal",
                        "url": "/api/v1/questions/1/proposals/4",
                        "abstract": null,
                        "created": "2013-08-15 18:32:00.228671",
                        "id": "4",
                        "blurb": "Harry edits like a champ",
                        "generation_created": "1"
                      }
                    ],
                    "PF_plus": [],
                    "PF_minus": [
                      {
                        "question_url": "/api/v1/questions/1",
                        "author_url": "/api/v1/users/3",
                        "title": "Bills Second Proposal",
                        "url": "/api/v1/questions/1/proposals/2",
                        "abstract": "This is too abstract for an abstract",
                        "created": "2013-08-15 18:32:00.176816",
                        "id": "2",
                        "blurb": "Bills blurb of varying disinterest",
                        "generation_created": "1"
                      }
                    ]
                  }
                },
                {
                  "1": {}
                }
              ],
              "num_items": "5",
              "question_id": "1"
            }

        :json username: username
        :json email: email address
        :json password: password
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_question_endorser_effects called with %s...\n",
                     question_id)

    if question_id is None:
        app.logger.debug("ERROR: question_id is None!\n")
        abort(404)

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        abort(404)

    generation = int(request.args.get('generation', question.generation))
    endorser_effects = question.\
        calculate_endorser_effects(generation=generation)

    app.logger.debug("Endorser Effects==> %s", endorser_effects)

    results = []
    for (endorser, effects) in endorser_effects.iteritems():
        endorser_effects = dict()

        if not effects is None:
            PF_excluding_pulbic = replaceWithPublic(effects['PF_excluding'])
            PF_plus_public = replaceWithPublic(effects['PF_plus'])
            PF_minus_public = replaceWithPublic(effects['PF_minus'])

            endorser_effects = {
                'PF_excluding': PF_excluding_pulbic,
                'PF_plus': PF_plus_public,
                'PF_minus': PF_minus_public}
        else:
            endorser_effects = {}

        results.append({endorser.id: endorser_effects})

    return jsonify(question_id=str(question.id),
                   query_generation=str(generation),
                   current_generation=str(question.generation),
                   num_items=str(len(results)), objects=results), 200


def replaceWithPublic(collection):
    public = []
    for c in collection:
        public.append(c.get_public())
    return public


# 
# Get graph
#
# http://[hostname]/api/v1.0/questions/47/graph?generation=2&map_type=pareto
@app.route('/api/v1/questions/<int:question_id>/graph', methods=['GET'])
def api_question_graph(question_id):
    '''
    .. http:get:: questions/(int:question_id)/graph

        Get the Voting map for this generation.

        **Example request**:

        .. sourcecode:: http

              GET /questions/42/graph?graph_type=pareto&genration=3 HTTP/1.1
              Host: example.com
              Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
             "question_id": 42,
             "graph_generation": 3,
             "graph_type": "all",
             "current_generation": 4,
             "url": "/maps/map_Q42_G4_all_1_1.svg"
            }

        :param question_id: question ID
        :type question_id: int
        :query map_type: map type. default is all generation proposals
        :type map_type: string: either "all" or "pareto", defaults to "all"
        :query generation: question generation
        :type generation: int
        :query proposal_level_type: proposal node layout, defaults to "layers"
        :type proposal_level_type: string: one of "layers", "num_votes" or "flat"
        :query user_level_type: user node layout, defaults to "layers"
        :type user_level_type: string: one of "layers", "num_votes" or "flat"

        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_question_graph called...\n")

    app.logger.debug("************** USING ALGORITHM %s ************", app.config['ALGORITHM_VERSION'])

    if question_id is None:
        app.logger.debug("ERROR: question_id is None!\n")
        abort(404)

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        abort(404)

    generation = int(request.args.get('generation', question.generation))

    # set Algorithm version
    algorithm = int(request.args.get('algorithm', app.config['ALGORITHM_VERSION']))

    # app.logger.debug('Question has %s endorsememnts', question.has_endorsememnts(generation))
    if not question.has_endorsememnts(generation):
        return jsonify(message="No endorsements yet"), 204

    map_type = request.args.get('map_type', 'all')
    proposal_level_type = request.args.get('proposal_level_type',
                                           models.GraphLevelType.layers)
    user_level_type = request.args.get('user_level_type',
                                       models.GraphLevelType.layers)

    '''
    filename_hashed = models.make_map_filename_hashed(question=question,
                                                      generation=generation,
                                                      map_type=map_type,
                                                      proposal_level_type=proposal_level_type,
                                                      user_level_type=user_level_type)
    app.logger.debug('filename_hashed ==> %s', filename_hashed)'''

    app.logger.debug("Call get_voting_graph()...")
    graph_svg = question.get_voting_graph(
        generation=generation,
        map_type=map_type,
        proposal_level_type=proposal_level_type,
        user_level_type=user_level_type,
        algorithm=algorithm)

    if not graph_svg:
        message = "There was a problem creating the graph"
        return jsonify(message=message), 500

    return jsonify(question_id=str(question.id),
                   map_type=map_type,
                   graph_generation=str(generation),
                   current_generation=str(question.generation),
                   url='http://' + app.config['SITE_DOMAIN'] + '/' + app.config['EXTERNAL_MAP_PATH'] +
                       graph_svg,
                   proposal_level_type=proposal_level_type,
                   user_level_type=user_level_type), 200

@app.route('/api/v1/questions/<int:question_id>/voting_map',
           methods=['GET'])
def api_question_voting_map(question_id):
    '''
    .. http:post:: questions/(int:question_id)/voting_map

        A map of proposal dominations.

        **Example request**:

        .. sourcecode:: http

            GET questions/42/voting_map HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json


        :param question_id: question id
        :type question_id: int
        :param generation: generation
        :type generation: int
        :param algorithm: algorithm id
        :type algorithm: int
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_question_voting_map called with %s...\n",
                     question_id)

    if question_id is None:
        app.logger.debug("ERROR: question_id is None!\n")
        abort(404)

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        abort(404)

    generation = int(request.args.get('generation', question.generation))

    voting_map = question.voting_map()
    
    # app.logger.debug("voting_map=====>%s", voting_map)

    return jsonify(
        question_id=str(question.id),
        current_generation=str(question.generation),
        num_items=str(len(voting_map)),
        voting_map=voting_map), 200

@app.route('/api/v1/questions/<int:question_id>/levels_map',
           methods=['GET'])
def api_question_levels_map(question_id=None):
    '''
    .. http:post:: questions/(int:question_id)/levels_map

        A map of proposal dominations.

        **Example request**:

        .. sourcecode:: http

            GET questions/42/levels_map HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json


        :param question_id: question id
        :type question_id: int
        :param generation: generation
        :type generation: int
        :param algorithm: algorithm id
        :type algorithm: int
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_question_levels_map called with %s...\n",
                     question_id)

    if question_id is None:
        app.logger.debug("ERROR: question_id is None!\n")
        abort(404)

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        abort(404)

    generation = int(request.args.get('generation', question.generation))
    # set Algorithm version
    algorithm = int(request.args.get('algorithm', app.config['ALGORITHM_VERSION']))

    levels =\
        question.calculate_levels_map(generation=generation, algorithm=algorithm)
    app.logger.debug("levels=====>%s", levels)
    
    levels_map = []
    for (proposal_id, levels) in levels.iteritems():
        levels_map.append({"id": proposal_id, "levels": levels})

    return jsonify(
        question_id=str(question.id),
        query_generation=str(generation),
        current_generation=str(question.generation),
        num_items=str(len(levels_map)),
        levels_map=levels_map), 200

@app.route('/api/v1/questions/<int:question_id>/domination_map',
           methods=['GET'])
def api_question_domination_map(question_id=None):
    '''
    .. http:post:: questions/(int:question_id)/domination_map

        A map of proposal dominations.

        **Example request**:

        .. sourcecode:: http

            GET questions/42/domination_map HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json


        :param question_id: question id
        :type question_id: int
        :param generation: generation
        :type generation: int
        :param algorithm: algorithm id
        :type algorithm: int
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_question_domination_map called with %s...\n",
                     question_id)

    if question_id is None:
        app.logger.debug("ERROR: question_id is None!\n")
        abort(404)

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        abort(404)

    generation = int(request.args.get('generation', question.generation))
    # set Algorithm version
    algorithm = int(request.args.get('algorithm', app.config['ALGORITHM_VERSION']))

    # domination_map =\
    #     question.calculate_domination_map(generation=generation, algorithm=algorithm)
    
    relations =\
        question.calculate_domination_map(generation=generation, algorithm=algorithm)
    keys = relations.keys()
    app.logger.debug("Domination Map: keys ==> %s", keys)

    app.logger.debug("Domination Map: relations ==> %s", relations)
    
    domination_map = []

    for (proposal_id, dominations) in relations.iteritems():

        '''
        app.logger.debug("Processing relations for proposal %s", proposal.id)
        app.logger.debug("%s Dominated ==>%s", proposal.id, relations['dominated'])
        app.logger.debug("%s Dominating ==>%s", proposal.id, relations['dominating'])
        '''
        '''
        doms = []
        for (pid, relation) in dominations.iteritems():
            doms.append({"pid": pid, "relation": relation})
        '''
        # app.logger.debug("dominations===>>>>> %s", dominations)

        app.logger.debug("Dom Table Symbols: %s", DOMINATION_MAP_SYMBOLS)
        domination_list = []
        for pid in keys:
            domination_list.append( DOMINATION_MAP_SYMBOLS[ dominations[pid] ] )
        domination_map.append({"id": int(proposal_id), "dominations": domination_list})

        # app.logger.debug("domination_map==>%s", domination_map)

    return jsonify(
        question_id=str(question.id),
        query_generation=str(generation),
        current_generation=str(question.generation),
        num_items=str(len(domination_map)),
        domination_map=domination_map), 200

@app.route('/api/v1/questions/<int:question_id>/proposal_relations',
           methods=['GET'])
def api_question_proposal_relations(question_id=None):
    '''
    .. http:post:: questions/(int:question_id)/proposal_relations

        A list of proposal relations.

        **Example request**:

        .. sourcecode:: http

            GET questions/42/proposal_relations HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
              "query_generation": "1",
              "current_generation": "1",
              "objects": [
                {
                  "3": {
                    "dominating": [
                      {
                        "question_url": "/api/v1/questions/1",
                        "author_url": "/api/v1/users/3",
                        "title": "Bills First Proposal",
                        "url": "/api/v1/questions/1/proposals/1",
                        "abstract": null,
                        "created": "2013-08-13 10:42:55.625328",
                        "id": "1",
                        "blurb": "Bills blurb of varying interest",
                        "generation_created": "1"
                      }
                    ],
                    "dominated": []
                  }
                },
                {
                  "2": {
                    "dominating": [],
                    "dominated": []
                  }
                },
                {
                  "1": {
                    "dominating": [],
                    "dominated": [
                      {
                        "question_url": "/api/v1/questions/1",
                        "author_url": "/api/v1/users/2",
                        "title": "Susans Only Proposal",
                        "url": "/api/v1/questions/1/proposals/3",
                        "abstract": "Blah blah blah",
                        "created": "2013-08-13 10:42:55.664450",
                        "id": "3",
                        "blurb": "My blub is cool",
                        "generation_created": "1"
                      }
                    ]
                  }
                },
                {
                  "4": {
                    "dominating": [],
                    "dominated": []
                  }
                }
              ],
              "num_items": "4",
              "question_id": "1"
            }

        :param question_id: question id
        :type question_id: int
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_question_proposal_relations called with %s...\n",
                     question_id)

    if question_id is None:
        app.logger.debug("ERROR: question_id is None!\n")
        abort(404)

    question = models.Question.query.get(int(question_id))

    if question is None:
        app.logger.debug("ERROR: Question %s Not Found!\n", question_id)
        abort(404)

    generation = int(request.args.get('generation', question.generation))
    proposal_relations =\
        question.calculate_proposal_relations(generation=generation)

    app.logger.debug("Proposal Relations==> %s", proposal_relations)

    results = []
    for (proposal, relations) in proposal_relations.iteritems():
        dominated_public = replaceWithPublic(relations['dominated'])
        dominating_public = replaceWithPublic(relations['dominating'])

        prop_relations = {
            'dominated': dominated_public,
            'dominating': dominating_public}

        results.append({proposal.id: prop_relations})

    return jsonify(
        question_id=str(question.id),
        query_generation=str(generation),
        current_generation=str(question.generation),
        num_items=str(len(proposal_relations)), proposal_relations=results), 200


# Get Invitations
@app.route('/api/v1/questions/<int:question_id>/invitations',
           methods=['GET'])
def api_get_invitations(question_id):
    '''
    .. http:get:: /questions/(int:question_id)/invitations

        A list of invitations for a question.

        **Example request**:

        .. sourcecode:: http

            GET /questions/45/invitations HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
              "total_items": "4",
              "items": "2",
              "objects": [
                {
                  "receiver_id": "/api/v1/users/2",
                  "sender_url": "/api/v1/users/1",
                  "sender_id": 1,
                  "id": "1",
                  "question_id": 1
                },
                {
                  "receiver_id": "/api/v1/users/3",
                  "sender_url": "/api/v1/users/1",
                  "sender_id": 1,
                  "id": "2",
                  "question_id": 1
                }
              ],
              "page": "1",
              "pages": "2"
            }

        :param question_id: question ID
        :type question_id: int
        :query page: results page number, default is 1
        :statuscode 201: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_get_invitations called...\n")

    if question_id is None:
        abort(404)

    question = models.Question.query.get(int(question_id))
    if question is None:
        abort(400)

    page = int(request.args.get('page', 1))

    invites = models.Invite.query.filter(
        models.Invite.question_id == int(question_id)).\
        paginate(page, RESULTS_PER_PAGE, False)

    items = len(invites.items)
    pages = invites.pages
    total_items = invites.total

    results = []
    for i in invites.items:
        results.append(i.get_public())

    return jsonify(total_items=str(total_items), items=str(items),
                   page=str(page), pages=str(pages),
                   invitations=results), 200


# Create Invitation
@app.route('/api/v1/questions/<int:question_id>/invitations',
           methods=['POST'])
@requires_auth
def api_create_invitation(question_id):
    '''
    .. http:post:: questions/(int:question_id)/invitations

        Create invitations to a question.

        **Example request**:

        .. sourcecode:: http

            POST questions/45/invitations HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
              "message": "Invites sent"
            }

        :param question_id: question id
        :type question_id: int
        :json invite_user_ids: list of user ids to invite
        :statuscode 201: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_create_invitation called...\n")

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    app.logger.debug("Authenticated User = %s\n", user.id)

    if question_id is None:
        abort(404)

    if not request.json:
        abort(400)

    if not 'invite_user_ids' in request.json:
        abort(400)

    invite_user_ids = request.json['invite_user_ids']

    for id in invite_user_ids:
        try:
            id = int(id)
        except ValueError:
            app.logger.debug(
                "Param invite_user_ids contains non integer values!\n")
            abort(400)

    app.logger.debug("invite_user_ids = %s\n", invite_user_ids)

    question = models.Question.query.get(int(question_id))
    if question is None:
        abort(400)

    app.logger.debug("calling invite_all with users %s\n", invite_user_ids)
    if user.invite_all(invite_user_ids, question):
        app.logger.debug("invites created\n")
        db_session.commit()
        return jsonify(message="Invites sent"), 201
    else:
        abort(500)


# Get subscriptions
#
@app.route('/api/v1/users/<int:user_id>/subscriptions', methods=['GET'])
@app.route('/api/v1/users/<int:user_id>/subscriptions/<int:question_id>',
           methods=['GET'])
def api_get_user_subscriptions(user_id, question_id=None):
    '''
    .. http:get:: users/(int:user_id)/subscriptions

        A subscription or list of subscriptions to a question.

        **Example request**:

        .. sourcecode:: http

            GET users/12/subscriptions HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
              "total_items": 3,
              "items": 2,
              "objects": [
                {
                  "url": "/users/1/subscriptions/1",
                  "how": "asap",
                  "last_update": "None",
                  "question_id": "1"
                },
                {
                  "url": "/users/1/subscriptions/2",
                  "how": "asap",
                  "last_update": "None",
                  "question_id": "2"
                }
              ],
              "page": "1",
              "pages": "2"
            }

        :param user_id: user id
        :type user_id: int
        :param question_id: question id
        :type question_id: int
        :query page: page number, defaults to 1
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_get_user_subscriptions called...\n")

    if user_id is None:
        abort(404)

    user = models.User.query.get(int(user_id))

    if question_id is not None:

        subscribed_question = user.subscribed_questions.\
            filter(models.Update.question_id == int(question_id)).one()

        if subscribed_question is None:
            abort(404)

        app.logger.debug("Subscribed question ID %s\n",
                         subscribed_question.question_id)
        '''
        subscriptions = [{'question_id': subscribed_question.question_id,
                          'how': subscribed_question.how,
                          'last_update': str(subscribed_question.last_update)}]
        '''
        results = [subscribed_question.get_public()]
        return jsonify(object=results), 200

    else:
        page = int(request.args.get('page', 1))
        subscribed_questions = user.subscribed_questions.\
            paginate(page, RESULTS_PER_PAGE, False)
        items = len(subscribed_questions.items)
        pages = subscribed_questions.pages
        total_items = subscribed_questions.total

        results = []
        for s in subscribed_questions.items:
            results.append(s.get_public())

        return jsonify(total_items=total_items, items=(items),
                       page=str(page), pages=str(pages),
                       subscriptions=results), 200


#
# Create Subscription
#
@app.route('/api/v1/users/<int:user_id>/subscriptions', methods=['POST'])
@requires_auth
def api_add_user_subscriptions(user_id):
    '''
    .. http:post:: /users/(int:user_id)/subscriptions

        Create a subscription.

        **Example request**:

        .. sourcecode:: http

            POST /users/22/subscriptions HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
              "url": "/api/v1/users/1/subscriptions/1"
            }

        :param user_id: user id
        :type user_id: int
        :json question_id: question id
        :json how: one of daily, weekly, or asap
        :statuscode 201: no error
        :statuscode 400: bad request
        :statuscode 401: unauthorized
    '''
    app.logger.debug("api_add_user_subscriptions called...\n")

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    app.logger.debug("Authenticated User = %s\n", user.id)

    if not request.json:
        abort(400)

    if not 'how' in request.json\
            or not request.json['how'] in ['daily', 'weekly', 'asap']:
        abort(400)

    if not 'question_id' in request.json:
        abort(400)

    question_id = int(request.json['question_id'])
    how = request.json['how']

    if user.subscribed_questions.filter(
            models.Update.question_id == question_id).count() == 1:
        abort(400)

    question = models.Question.query.get(question_id)
    if question is None:
        abort(400)

    user.subscribe_to(question, how)
    db_session.add(user)
    db_session.commit()

    return jsonify({'url': url_for('api_get_user_subscriptions',
                                   user_id=user_id,
                                   question_id=question_id)}), 201


#
# Update subscription
#
@app.route('/api/v1/users/<int:user_id>/subscriptions',
           methods=['PATCH'])
@requires_auth
def api_update_user_subscriptions(user_id):
    '''
    .. http:patch:: /users/(int:user_id)/subscriptions

        Update a user's question subscription'.

        **Example request**:

        .. sourcecode:: http

            PATCH users/56/subscriptions HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 201 OK
            Content-Type: application/json

            {
              "objects": [
                {
                  "how": "asap",
                  "last_update": "None",
                  "question_id": 3
                }
              ]
            }

        :param user_id: user id
        :type user_id: int
        :json question_id: question id
        :json how: one of daily, weekly, or asap
        :statuscode 201: no error
        :statuscode 400: bad request
        :statuscode 401: unauthorized
    '''
    app.logger.debug("api_update_user_subscriptions called...\n")

    user = get_authenticated_user(request)
    if not user:
        abort(401)

    app.logger.debug("Authenticated User = %s\n", user.id)

    if not request.json:
        abort(400)

    if user_id is None:
        abort(400)

    if user.id != user_id:
        abort(401)

    if not 'question_id' in request.json:
        msg_txt = "You must supply the parameter 'question_id' " +\
                  "set to the id of the question" +\
                  "you wish to subscribe to"
        message = {"message": msg_txt}
        return jsonify(message), 400

    question_id = int(request.json['question_id'])

    if not 'how' in request.json \
            or not request.json['how'] in ['daily', 'weekly', 'asap']:
        msg_txt = "You must supply the parameter 'how' " +\
                  "set to one of the desired" +\
                  "update methods: 'daily', 'weekly', 'asap'"
        message = {"message": msg_txt}
        return jsonify(message), 400

    subscription = user.subscribed_questions.\
        filter(models.Update.question_id == int(question_id)).first()

    if subscription is None:
        abort(404)

    subscription.how = request.json['how']
    # db_session.add(user)
    db_session.commit()

    subscription = [{'question_id': subscription.question_id,
                    'how': subscription.how,
                    'last_update': str(subscription.last_update)}]

    return jsonify(objects=subscription), 201


# Delete subscription
#
# @app.route('/api/v1/subscriptions/<int:question_id>',
@app.route('/api/v1/users/<int:user_id>/subscriptions/<int:question_id>',
           methods=['DELETE'])
@requires_auth
def api_delete_user_subscriptions(user_id, question_id):
    '''
    .. http:delete:: /users/(int:user_id)/subscriptions/(int:question_id)

        Delete a question subscription.

        **Example request**:

        .. sourcecode:: http

            DELETE users/56/subscriptions/44 HTTP/1.1
            Host: example.com
            Accept: application/json

        **Example response**:

        .. sourcecode:: http

            Status Code: 200 OK
            Content-Type: application/json

            {
            "message": "Subscription Deleted"
            }

        :param user_id: user id
        :type user_id: int
        :param question_id: question id
        :type question_id: int
        :statuscode 200: no error
        :statuscode 400: bad request
    '''
    app.logger.debug("api_delete_user_subscriptions called...\n")

    user = get_authenticated_user(request)

    if user is None:
        abort(404)

    if user_id is None:
        abort(400)

    if user.id != user_id:
        abort(401)

    if question_id is None:
        abort(404)

    app.logger.debug("Authenticated User = %s\n", user.id)

    subscription = user.subscribed_questions.filter(and_(
        models.Update.question_id == int(question_id),
        models.Update.user_id == user.id)).first()

    if subscription is not None:
        user.subscribed_questions.remove(subscription)
    db_session.add(user)
    db_session.commit()
    return jsonify(message="Subscription deleted"), 200
